<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>bencode@编码</title>
    <description></description>
    <link>http://bencode.github.io/</link>
    <atom:link href="http://bencode.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 17 Dec 2014 23:20:29 +0800</pubDate>
    <lastBuildDate>Wed, 17 Dec 2014 23:20:29 +0800</lastBuildDate>
    <generator>Jekyll v2.4.0</generator>
    
      <item>
        <title>nginx配置error_page</title>
        <description>&lt;p&gt;官网文档：&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#error_page&quot;&gt;查看&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;注意点是，如果error_page指向的页面是一个远程地址，如http://demo.com/errorpage.html&lt;br /&gt;
那默认页面会进行302跳转，而不管原来的状态码。&lt;/p&gt;

&lt;p&gt;如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error_page 404      http://demo.com/404.html;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;则nginx会302到以上页面，这样会对SEO有影响，我们希望实现对页面进行代理请求&lt;/p&gt;

&lt;p&gt;此时可以配合proxy-pass做一个中间层&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;location / {
    error_page 404 /404;
}

location /404 {
    proxy_pass http://demo.com/404.html;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文档中有这样的例子，但是我试过无效果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;location / {
    error_page 404 = @fallback;
}

location @fallback {
    proxy_pass http://backend;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会出现指令出错。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
nginx: [emerg] &quot;proxy_pass&quot; cannot have URI part in location given by regular expression, or inside named location, or inside &quot;if&quot; statement, or inside &quot;limit_except&quot; block in
&lt;/code&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 01 Dec 2014 00:00:00 +0800</pubDate>
        <link>http://bencode.github.io/nginx/error_page.html</link>
        <guid isPermaLink="true">http://bencode.github.io/nginx/error_page.html</guid>
        
        
        <category>nginx</category>
        
      </item>
    
      <item>
        <title>eclipse review</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;一些名词&lt;/h2&gt;

&lt;p&gt;plug-ins&lt;/p&gt;

&lt;p&gt;structed bundle of code and/or data to contribute functionality to system&lt;/p&gt;

&lt;p&gt;extensions extension-point&lt;/p&gt;

&lt;p&gt;JDT PDE&lt;/p&gt;

&lt;h2 id=&quot;runtime&quot;&gt;Runtime&lt;/h2&gt;

&lt;p&gt;manifest -&amp;gt; registry&lt;/p&gt;

&lt;p&gt;plugin = bundle&lt;/p&gt;

&lt;p&gt;定义在 org.eclipse.osgi and org.eclipse.core.runtime&lt;/p&gt;

&lt;p&gt;定义插件结构，实现加载策略&lt;/p&gt;

&lt;p&gt;找到并执行应用，维护plugin registry, extension and extension point&lt;/p&gt;

&lt;p&gt;提供一些基础设施：日志，调试，adapter，preference store，concurrency基础设施&lt;/p&gt;

&lt;p&gt;Bundle&lt;/p&gt;

&lt;p&gt;BundleActivator&lt;br /&gt;
  start(BundleContext)&lt;br /&gt;
  stop(BundleContext)&lt;/p&gt;

&lt;p&gt;BundleEvent&lt;br /&gt;
BundleContext&lt;/p&gt;

&lt;p&gt;Extension ExtensionPoint ExtensionRegistry&lt;/p&gt;

&lt;p&gt;ConfigurationElement&lt;/p&gt;

&lt;p&gt;Platform&lt;/p&gt;

&lt;h2 id=&quot;workbench&quot;&gt;Workbench&lt;/h2&gt;

&lt;p&gt;Workbench(WorkbenchWindow)&lt;/p&gt;

&lt;p&gt;Ppage: for group part&lt;/p&gt;

&lt;p&gt;Workbench&lt;br /&gt;
  - Page&lt;br /&gt;
    - MenuBar&lt;br /&gt;
    - ToolBar&lt;br /&gt;
    - StausLine&lt;br /&gt;
    - ShotcutBar&lt;/p&gt;

&lt;p&gt;Perspective:&lt;br /&gt;
  views, layout, actions&lt;/p&gt;

&lt;p&gt;切换perspective时,editor不受影响&lt;/p&gt;

&lt;p&gt;Part&lt;br /&gt;
1. ViewPart&lt;br /&gt;
2. EditPart: save-close lifecycle&lt;/p&gt;

&lt;p&gt;View and Editor&lt;/p&gt;

&lt;p&gt;createPartControl&lt;br /&gt;
setFocus&lt;br /&gt;
dispose&lt;/p&gt;
</description>
        <pubDate>Wed, 26 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://bencode.github.io/eclipse/review.html</link>
        <guid isPermaLink="true">http://bencode.github.io/eclipse/review.html</guid>
        
        
        <category>eclipse</category>
        
      </item>
    
      <item>
        <title>iframe自适应高度</title>
        <description>&lt;p&gt;这两天项目中需要，上网搜了一把找到一大堆，最后使用下面的方案。&lt;br /&gt;
发现一个问题，就是onload时再触发有点太慢了，可以改用domready等事件，还好我这个自适应不在线上使用，只存在开发环境下的mock。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var fn = function() {
  try {
    var bHeight = iframe.contentWindow.document.body.scrollHeight;
    var dHeight = iframe.contentWindow.document.documentElement.scrollHeight;
    var height = Math.max(bHeight, dHeight);
    if (height) {
      iframe.height = height;
    }
    setTimeout(fn, 200);
  } catch (e) {
    console.error(e);
  }
};

fn();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;http://www.cnblogs.com/MaxIE/archive/2008/08/13/1266597.html&lt;/p&gt;
</description>
        <pubDate>Tue, 25 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://bencode.github.io/web/iframe-autoresize.html</link>
        <guid isPermaLink="true">http://bencode.github.io/web/iframe-autoresize.html</guid>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>［译］Shadow DOM 101</title>
        <description>&lt;p&gt;正在进行中…&lt;/p&gt;
</description>
        <pubDate>Tue, 11 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://bencode.github.io/translation/shadow-dom-101.html</link>
        <guid isPermaLink="true">http://bencode.github.io/translation/shadow-dom-101.html</guid>
        
        
        <category>translation</category>
        
      </item>
    
      <item>
        <title>child_process的同步方法execSync</title>
        <description>&lt;p&gt;node中通过child_processt和shell交互很方便，只是0.10.x版本中的exec没有同步版本，让做“脚本”用途的node写起来很是麻烦。&lt;br /&gt;
而在0.11.12版本后添加了execSync方法解决了这个问题。&lt;/p&gt;

&lt;p&gt;首先node版本要到0.11.12以上才有这个api，可以使用n进行快速安装&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;sudo npm install -g n
n 0.11.14   // 到目前为止，已有0.11.14版了
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后就可以使用了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var exec = require(&#39;child_process&#39;).execSync;
exec(&#39;git log&#39;, { encoding: &#39;utf-8&#39; });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行一下，就发现控制台有git log的输出了 &lt;br /&gt;
上面在options中指定了encoding, 如果不指定，返回的是一个&lt;code&gt;Buffer&lt;/code&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 11 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://bencode.github.io/nodejs/exec-sync.html</link>
        <guid isPermaLink="true">http://bencode.github.io/nodejs/exec-sync.html</guid>
        
        
        <category>nodejs</category>
        
      </item>
    
      <item>
        <title>mruby源码阅读1</title>
        <description>&lt;p&gt;include/mrbconf.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define FALSE 0
define TRUE 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;include/mrb/value.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sun, 09 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://bencode.github.io/codereading/ruby/mruby-01.html</link>
        <guid isPermaLink="true">http://bencode.github.io/codereading/ruby/mruby-01.html</guid>
        
        
        <category>codereading</category>
        
        <category>ruby</category>
        
      </item>
    
      <item>
        <title>Polymer学习笔记 - HTML5 Template</title>
        <description>&lt;p&gt;&lt;a href=&quot;http://www.html5rocks.com/zh/tutorials/webcomponents/template/&quot;&gt;参考资料&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;特性检测&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;function supportTemplate() {
  return &#39;content&#39; in document.createElement(&#39;template&#39;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;声明模板内容&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;template id=&quot;mytemplate&quot;&amp;gt;
  &amp;lt;img src=&quot;&quot; alt=&quot;great image&quot;&amp;gt;
  &amp;lt;div class=&quot;comment&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;特性&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;模板内容在激活前不会被渲染&lt;/li&gt;
  &lt;li&gt;处于模板中的内容无副作用&lt;/li&gt;
  &lt;li&gt;处理模板中的内容不在文档中&lt;/li&gt;
  &lt;li&gt;模板可以放置在任意位置，包括&lt;code&gt;&amp;lt;head&amp;gt;, &amp;lt;body&amp;gt;, &amp;lt;frameset&amp;gt;&lt;/code&gt;&lt;br /&gt;
  并且任何能够出现在以上节点中的内容都可以出现在&lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;中&lt;br /&gt;
  template能够安全地出现在html解析器不允许出现的位置，几乎可以作为任何内容的子节点，如&lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-3&quot;&gt;激活&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var t = document.querySelector(&#39;#mytemplate&#39;)
t.content.querySelector(&#39;img&#39;).src = &#39;logo.png&#39;;

var clone = document.importNode(t.content, true);
document.body.appendChild(clone);
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 08 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://bencode.github.io/reading/polymer/template.html</link>
        <guid isPermaLink="true">http://bencode.github.io/reading/polymer/template.html</guid>
        
        
        <category>reading</category>
        
        <category>polymer</category>
        
      </item>
    
      <item>
        <title>Polymer学习笔记 - Shadow DOM</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;基本使用&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var el = document.createElement(&#39;div&#39;)
var shadow = el.createShadowRoot()
shadow.innerHTML = &#39;&amp;lt;content select=&quot;q&quot;&amp;gt;&amp;lt;/content&amp;gt;&#39;
document.body.appendChild(el)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;subtrees&quot;&gt;subtrees&lt;/h2&gt;

&lt;p&gt;一个节点承载三棵树： light DOM, shadow DOM 和 composed DOM&lt;/p&gt;

&lt;p&gt;组件提供者创建shadow DOM, 使用者提供light DOM， 然后浏览器结合两者成为composed DOM进行渲染。 &lt;br /&gt;
shadow DOM不能被用户访问到，它有自己的空间。 &lt;br /&gt;
这本质上是一种封装和开放，设计上的艺术。&lt;/p&gt;

&lt;h2 id=&quot;polyfill&quot;&gt;Polyfill&lt;/h2&gt;

&lt;p&gt;原生不支持ShadowDom的浏览器，可以使用ShadowDOMPolyfill来包装，只是即使这样，也有若干限制。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;事件重定向&lt;/h3&gt;

&lt;h3 id=&quot;section-2&quot;&gt;已知的缺陷&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;css封装性&lt;/li&gt;
  &lt;li&gt;Object.prototype.toString和原生支持的返回不一致&lt;/li&gt;
  &lt;li&gt;document, window, document.body, document.head等不可配置，不能被重写&lt;/li&gt;
  &lt;li&gt;跨window, frame未实现&lt;/li&gt;
  &lt;li&gt;:host()伪类选择器最多支持1层嵌套的括号选择器&lt;br /&gt;
例：&lt;code&gt;:host(.zot)&lt;/code&gt; and &lt;code&gt;:host(.zot:not(.bar))&lt;/code&gt; 支持, &lt;br /&gt;
  &lt;code&gt;:host(.zot:not(.bar:nth-child(2)))&lt;/code&gt; 不支持&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[资料]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.polymer-project.org/platform/shadow-dom.html&quot;&gt;https://www.polymer-project.org/platform/shadow-dom.html&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://dvcs.w3.org/hg/webcomponents/raw-file/57f8cfc4a7dc/explainer/index.html#shadow-dom-section&quot;&gt;https://dvcs.w3.org/hg/webcomponents/raw-file/57f8cfc4a7dc/explainer/index.html#shadow-dom-section&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/&quot;&gt;http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom-201/&quot;&gt;http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom-201/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom-301/&quot;&gt;http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom-301/&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 08 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://bencode.github.io/reading/polymer/shadow-dom.html</link>
        <guid isPermaLink="true">http://bencode.github.io/reading/polymer/shadow-dom.html</guid>
        
        
        <category>reading</category>
        
        <category>polymer</category>
        
      </item>
    
      <item>
        <title>Polymer学习笔记 - Helper Methods</title>
        <description>&lt;h2 id=&quot;html-imports&quot;&gt;动态Html imports&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;Polymer.import(urls, callback)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&amp;lt;dynamic-element&amp;gt;
  I&#39;m just an unknown element.
&amp;lt;/dynamic-element&amp;gt;

&amp;lt;script&amp;gt;
  var button = document.querySelector(&#39;button&#39;)
  button.addEventListener(&#39;click&#39;, function() {
    Polymer.import([&#39;dynamic-element.html&#39;], function() {
      document.querySelector(&#39;dynamic-element&#39;).description = &#39;a dynamic import&#39;
    })
  });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;mixins&quot;&gt;mixins&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;Polymer.mixin(target, obj1 [, obj2, ..., objN ] )
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section&quot;&gt;强制注册元素&lt;/h2&gt;

&lt;p&gt;默认情况下，Polymer会等待所有元素ready, 再进行注册和更新。 &lt;br /&gt;
如果一个元素没有调用Polymer构造函数，也没有使用noscript属性，则它会一直等待。 &lt;br /&gt;
Polymer.waitingFor帮助方法返回一个阻塞状态的polymer-element列表。  &lt;br /&gt;
Polymer.forceReady通知Polymer强制注册所有已ready的元素，忽略未完成的元素。&lt;/p&gt;
</description>
        <pubDate>Sat, 08 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://bencode.github.io/reading/polymer/helper-methods.html</link>
        <guid isPermaLink="true">http://bencode.github.io/reading/polymer/helper-methods.html</guid>
        
        
        <category>reading</category>
        
        <category>polymer</category>
        
      </item>
    
      <item>
        <title>Polymer学习笔记 - Data Binding</title>
        <description>&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;For Polymer elements, &lt;strong&gt;the model is always the element itself&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;polymer-element name=&quot;name-tag&quot;&amp;gt;
  &amp;lt;template&amp;gt;
    This is &amp;lt;b&amp;gt;{ {owner}}&amp;lt;/b&amp;gt;&#39;s name-tag element.
  &amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;document.querySelector(&#39;name-tag&#39;).owner = &#39;June&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;template&quot;&gt;&amp;lt;template&amp;gt;&lt;/h3&gt;

&lt;p&gt;在Polymer中，使用template定义自定义元素的shadow dom&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;数据绑定和事件处理&lt;/h3&gt;

&lt;p&gt;在事件绑定方法中可以取得事件源节点和模型&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;template repeat=&quot;{ {s in stories}}&quot;&amp;gt;
  &amp;lt;li on-click={ {selectStory}}&amp;gt;{ {s.headline}}&amp;lt;/li&amp;gt;

selectStory: function(e, detail, sender) {
  var story = e.target.templateInstance.model.s
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;types-of-bindings&quot;&gt;Types of bindings&lt;/h2&gt;

&lt;p&gt;有多种绑定数据和模板的方式&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;单模板实例&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;template bind=&quot;{ {person}}&quot;&amp;gt;
    This template can bind to the person object’s properties, like { {name}}.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了方便可以创建&lt;em&gt;name scope&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;template bind=&quot;persion as p&quot;&amp;gt;
  ... like { {p.name}}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;循环模板&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;template repeat=&quot;{ {array}}&quot;&amp;gt;
  Creates an instance with { {}} bindings  for every element in the array collection.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用空表达式&lt;code&gt;{ {}}&lt;/code&gt;表示当前对象&lt;/p&gt;

&lt;p&gt;repeat也支持&lt;em&gt;name scope&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;template repeat=&quot;{ {user, userIndex in users}}&quot;&amp;gt;
  { {user.name}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;repeat可以省略&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;this.items = [
  { name: &#39;Milk&#39; },
  ...
]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;template bind=&quot;{ {item}}&quot;&amp;gt;
  &amp;lt;p&amp;gt;items count: { {length}}
  &amp;lt;template repeat&amp;gt;
    &amp;lt;li&amp;gt;{ {name}}&amp;lt;/li&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;条件模板&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;template if=&quot;{ {conditionalValue}}&quot;&amp;gt;
  Binds if and only if conditionalValue is truthy.
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以混合使用&lt;em&gt;repeat&lt;/em&gt;和&lt;em&gt;if&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;template repeat=&quot;{ {item in list.items}}&quot; if=&quot;{ {list.showItems}}&quot;&amp;gt;
  &amp;lt;li&amp;gt;{ {item.name}}&amp;lt;/li&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-4&quot;&gt;引用模板&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;template id=&quot;myTemplate&quot;&amp;gt;
  这个模板可以被其他地方引用
&amp;lt;/template&amp;gt;

&amp;lt;template bind ref=&quot;myTemplate&quot;&amp;gt;
  这里的内容就忽略啦，使用myTemplate模板内容了
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;node-binding&quot;&gt;Node Binding&lt;/h3&gt;

&lt;p&gt;node binding用于关联节点和模型&lt;/p&gt;

&lt;p&gt;如何绑定依赖于节点类型和绑定名称，绑定名称和绑定在节点中出现的位置有关系&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;textContent 如 &lt;code&gt;&amp;lt;span&amp;gt;{ {someText}}&amp;lt;/span&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;styleName 如 &lt;code&gt;&amp;lt;span style=&quot;{ {someStyles}}&quot;&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-5&quot;&gt;文本绑定&lt;/h4&gt;

&lt;p&gt;出现在节点中间的绑定就是textContent binding&lt;/p&gt;

&lt;p&gt;比如 &lt;code&gt;&amp;lt;p&amp;gt;This paragraph has some { {adjective}} text.&amp;lt;/p&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;textContent绑定是单向的，改变模型，会改变内容, 但反之不会&lt;/p&gt;

&lt;h4 id=&quot;section-6&quot;&gt;属性绑定&lt;/h4&gt;

&lt;p&gt;如何进行属性绑定和节点类型和属性名有关&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;大部分标准dom的属性绑定都是单向的，比如style&lt;/li&gt;
  &lt;li&gt;表单元素，支持双向绑定&lt;/li&gt;
  &lt;li&gt;polymer element的公共属性是支持双向绑定的&lt;/li&gt;
  &lt;li&gt;自定义元素可以实现自己的绑定方式&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-7&quot;&gt;表单元素值的绑定&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;input元素的value和checked&lt;/li&gt;
  &lt;li&gt;options元素的value&lt;/li&gt;
  &lt;li&gt;select元素的selectIndex和value&lt;/li&gt;
  &lt;li&gt;textarea的value&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-8&quot;&gt;条件属性&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;span hidden?=&quot;{ {isHidden}}&quot;&amp;gt;This may or may not be hidden.&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-9&quot;&gt;一次性绑定&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;input type=&quot;text&quot; value=&quot;[[ obj.value ]]&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-10&quot;&gt;表达式&lt;/h2&gt;

&lt;h3 id=&quot;section-11&quot;&gt;行为和限制&lt;/h3&gt;

&lt;p&gt;表达式是javascript的子集&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;表达式用来处理简单的逻辑，不应该把复杂的逻辑放在表达式中&lt;/li&gt;
  &lt;li&gt;表达式从来不是使用eval执行，也不能访问global变量。&lt;/li&gt;
  &lt;li&gt;不能使用表达式插入HTML, 为了防止xss，默认对输出值进行html escape&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-12&quot;&gt;执行&lt;/h3&gt;

&lt;p&gt;表达式可以使用在以下三种情况 &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ {expression}}

[[expression]]

computed: {
  name: expression
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;scope&quot;&gt;上下文(scope)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;bind, repeat, if属性表达式使用的是父模板的作用域&lt;/li&gt;
  &lt;li&gt;最外层模板中表达式和computed属性表达式使用的作用域都是元素本身&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-13&quot;&gt;嵌套作用域规则&lt;/h3&gt;

&lt;p&gt;对于name scope模板，其父作用域是可见的，否则父作用域不可见&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;!-- outermost template -- element&#39;s properties available --&amp;gt;
  &amp;lt;template bind=&quot;{ {organization as organization}}&quot;&amp;gt;
    &amp;lt;!-- organization.* available --&amp;gt;
    &amp;lt;template bind=&quot;{ {organization.contact as contact}}&quot;&amp;gt;
      &amp;lt;!-- organization.* &amp;amp; contact.* available --&amp;gt;
      &amp;lt;template bind=&quot;{ {contact.address}}&quot;&amp;gt;
        &amp;lt;!-- only properties of address are available --&amp;gt;
        &amp;lt;template bind=&quot;{ {streetAddress as streetAddress}}&quot;&amp;gt;
          &amp;lt;!-- streetAddress.* and properties of address are available.
               NOT organization.* or contact.* --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-14&quot;&gt;过滤器&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;{ {user | formatUserName}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的方式，如果user中的字段变化了，表达式不会重新求值,  &lt;br /&gt;
因为表达式不知道应该监听什么属性变化，所以得主动告诉它。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;{ { {firstName: user.firstName, lastName: user.lastName} | formatUserName}}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;tokenlist-styleobject&quot;&gt;tokenList, styleObject&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div class=&quot;{ }&quot;  
&amp;lt;div style=&quot;{ {styles | styleObject}}&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-15&quot;&gt;自定义过滤器&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;Polymer(&#39;greeting-tag&#39;, {
  ...
  toUpperCase: function(value) {
    return value.toUpperCase()
  },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要处理双向绑定的过滤器：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;toUpperCase: {
  toDOM: function(value) {
    return value.toUpperCase()
  },
  toModel: function(value) {
    return value.toLowerCase()
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-16&quot;&gt;过滤器参数&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;{ {myNumber | toFixed(2)}}

toFixed: function(value, precision) {
  return Number(value).toFixed(precision)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;chaining-filter&quot;&gt;chaining filter&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;{ {myNumber | toHex | toUpperCase}}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-17&quot;&gt;自定义全局过滤器&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;PolymerExpressions.prototype.uppercase = function(input) {
  return input.toUpperCase()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;全局过滤器使用html import方式载入&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;link rel=&quot;import&quot; href=&quot;uppercase-filter.html&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-18&quot;&gt;兼容性相关的注意事项&lt;/h2&gt;

&lt;p&gt;不支持template的浏览器，将不支持template节点存在于某些元素里，比如select和table&lt;/p&gt;

&lt;p&gt;Polymer采用变通的方式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;table&amp;gt;
  &amp;lt;tr template repeat=&quot;{ {tr in rows}}&quot;&amp;gt;
    &amp;lt;td&amp;gt;Hello&amp;lt;/td&amp;gt;
  &amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;select的例子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;polymer-element name=&quot;my-select&quot;&amp;gt;
  &amp;lt;template&amp;gt;
    &amp;lt;select&amp;gt;
      &amp;lt;option template repeat=&quot;{ {options}}&quot;&amp;gt;{ {}}&amp;lt;/option&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有些浏览器对属性值中有特殊字符不支持，如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;img src=&quot;/users/{ {id}}.jpg&quot; /&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以在属性前加_&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;img _src=&quot;/users/{ {id}}.jpg&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-19&quot;&gt;数据绑定如何工作&lt;/h2&gt;

&lt;p&gt;Polymer在数据绑定时，不是像传统的ajax那样，会将整片dom进行替换，  &lt;br /&gt;
而是进行&lt;strong&gt;最小的必要的dom变化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;table&amp;gt;
    &amp;lt;template repeat=&quot;{ {item in items}}&quot;&amp;gt;
      &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt; { {item.name}} &amp;lt;/td&amp;gt;&amp;lt;td&amp;gt; { {item.count}} &amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
    &amp;lt;/template&amp;gt;
   &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt; Bass &amp;lt;/td&amp;gt;&amp;lt;td&amp;gt; 7 &amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;  
   &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt; Catfish &amp;lt;/td&amp;gt;&amp;lt;td&amp;gt; 8 &amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt; 
   &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt; Trout &amp;lt;/td&amp;gt;&amp;lt;td&amp;gt; 0 &amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比如现在你对items进行重新排序，polymer不会创建和销毁dom，仅仅也是重新排列一下dom&lt;/p&gt;

&lt;p&gt;如果改变了一个item的count，则只会改变一个td中的值&lt;/p&gt;

&lt;h3 id=&quot;section-20&quot;&gt;数据绑定如何跟踪每个模板实例&lt;/h3&gt;

&lt;p&gt;当模板创建一个或多个实例，它会将实例插入紧跟着模板的位置，并且跟踪每个实例最后节点  &lt;br /&gt;
这样第一个实例就是模板结尾开始到第一个实例结尾，后面的依旧。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;template repeat=&quot;{ {item in myList}}&quot;&amp;gt;
  &amp;lt;img&amp;gt;
  &amp;lt;span&amp;gt;{ {item.name}}&amp;lt;/span&amp;gt;
&amp;lt;/template&amp;gt;                  
  &amp;lt;img&amp;gt;
  &amp;lt;span&amp;gt;foo&amp;lt;/span&amp;gt;   ⇐ terminating node in template instance
  &amp;lt;img&amp;gt;
  &amp;lt;span&amp;gt;bar&amp;lt;/span&amp;gt;   ⇐ terminating node in template instance
  &amp;lt;img&amp;gt;
  &amp;lt;span&amp;gt;baz&amp;lt;/span&amp;gt;   ⇐ terminating node in template instance
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-21&quot;&gt;直接操作模板生成的节点&lt;/h3&gt;

&lt;p&gt;正常情况下，你不应该直接去修改模板生成的dom。 &lt;br /&gt;
非要修改，根据上面的原理，只要不修改最后一个节点，那问题是不大的。 &lt;br /&gt;
所以如果要修改，一般来说嵌套一层，只修改里面的dom节点。 &lt;br /&gt;
但是当修改模型后，修改的dom可能会被替换，因为双向数据绑定只针对于表单域。&lt;/p&gt;

&lt;h2 id=&quot;polymer-element&quot;&gt;在Polymer Element之外使用数据绑定&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;使用auto-binding template&lt;/li&gt;
  &lt;li&gt;可以直接使用&lt;a href=&quot;https://github.com/polymer/TemplateBinding&quot;&gt;TemplateBinding&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;auto-binding-template&quot;&gt;使用auto-binding template可以享有以下特性&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;完整的数据绑定功能&lt;/li&gt;
  &lt;li&gt;声明式事件映射&lt;/li&gt;
  &lt;li&gt;自动节点查找&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;template-binding&quot;&gt;Template Binding&lt;/h2&gt;

&lt;p&gt;Polymer的Template Binding扩展了Html TemplateElement, 让它支持数据绑定的方式来创建，管理和移除内容。&lt;/p&gt;

&lt;p&gt;可以独立使用Template Binding&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;template id=&quot;greeting&quot; bind=&quot;{ { salutations }}&quot;&amp;gt;
  Hello, { {who}} - { {what}}
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
  var t = document.querySelector(&#39;#greeting&#39;)
  var model = {
    salutations: { what: &#39;GoodBye&#39;, who: &#39;Imperative&#39; }
  }
  t.model = model   // &amp;lt;-- 设置模型
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;nodebind&quot;&gt;Node.bind()&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/polymer/NodeBind&quot;&gt;Node.bind&lt;/a&gt; 用于数据绑定，可以将节点绑定到数据属性，它也可以独立的使用&lt;/p&gt;

&lt;h3 id=&quot;section-22&quot;&gt;基本使用&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var obj = {
  path: {
    to: {
      value: &#39;hi&#39;
    }
  }
}

var textNode = document.createTextNode(&#39;mytext&#39;)
textNode.bind(&#39;textContent&#39;, new PathObserver(obj, &#39;path.to.value&#39;))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-23&quot;&gt;绑定类型&lt;/h3&gt;

&lt;p&gt;以下类型可以进行双向绑定&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Text node - textContent&lt;/li&gt;
  &lt;li&gt;HtmlInputElement - value &amp;amp; checked&lt;/li&gt;
  &lt;li&gt;HtmlTextareaElement - value&lt;/li&gt;
  &lt;li&gt;HtmlSelectElement - value 和 selectedIndex&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以其他的都绑定到元素属性&lt;/p&gt;

&lt;h3 id=&quot;section-24&quot;&gt;自定义元素的绑定&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;MyFancyHTMLWidget.prototype.bind = function(name, observable, oneTime) {
  if (name == &#39;myBinding&#39;) {
    // interpret the binding meaning
    // if oneTime is false, this should return an object which
    // has a close() method.
    // this will allow TemplateBinding to clean up this binding
    // when the instance containing it is removed.
  } else {
    return HTMLElement.prototype.bind.call(
      this, name, observable, oneTime
    )
  }
}
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Fri, 07 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://bencode.github.io/reading/polymer/data-binding.html</link>
        <guid isPermaLink="true">http://bencode.github.io/reading/polymer/data-binding.html</guid>
        
        
        <category>reading</category>
        
        <category>polymer</category>
        
      </item>
    
  </channel>
</rss>
