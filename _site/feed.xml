<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>bencode@编码</title>
    <description></description>
    <link>http://bencode.github.io/</link>
    <atom:link href="http://bencode.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 07 Nov 2014 19:41:45 +0800</pubDate>
    <lastBuildDate>Fri, 07 Nov 2014 19:41:45 +0800</lastBuildDate>
    <generator>Jekyll v2.4.0</generator>
    
      <item>
        <title>Polymer 学习记录(API Developer Guide)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://www.polymer-project.org/docs/polymer/polymer.html&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;help make developing web components much easier&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;申明&lt;/h2&gt;

&lt;p&gt;使用&lt;code&gt;&amp;lt;polymer-element&amp;gt;&lt;/code&gt;申明组件&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;属性&lt;/h2&gt;

&lt;p&gt;有一些保留的attributes用于描述组件  &lt;br /&gt;
如：&lt;em&gt;name, attributes, extends, noscript, constractor&lt;/em&gt;&lt;br /&gt;
其他的属性将会自动应用到组件  &lt;br /&gt;
属性名的大小写是无关紧要的，polymer会聪明地应用到实际对象上&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;注册&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;Polymer(tag-name, prototype)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;custom-element-prototype-chain&quot;&gt;Custom element prototype chain&lt;/h2&gt;

&lt;p&gt;Polymer对象属性和方法的继承链：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;prototype对象中定义的属性和方法&lt;/li&gt;
  &lt;li&gt;Polymer定义的基本属性和方法&lt;/li&gt;
  &lt;li&gt;HTML Element的属性和方法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以为了避免冲突，请不要定义&lt;em&gt;id, children, focus, title, hidden&lt;/em&gt;等属性和方法&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;结果不可预料 ？ &amp;lt;－－ 文档中是这么说的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-3&quot;&gt;属性的引用&lt;/h2&gt;

&lt;p&gt;在模板中 &lt;code&gt;$.globals.firstName&lt;/code&gt;  &lt;br /&gt;
在js中 &lt;code&gt;this.$.globals.firstName&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;生命周期&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;{
  created: function() {},  
  ready: function() {},  
  attached: function() {},
  domReady: function() {},  
  detached: function() {},  
  attributeChanged: function(name, oldValue, newValue) {}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;polymer-ready&quot;&gt;polymer-ready&lt;/h2&gt;

&lt;p&gt;polymer解析定义，更新以及载入资源都是异步的，所以需要一个类似domready的事件来防止&lt;a href=&quot;http://en.wikipedia.org/wiki/Flash_of_unstyled_content&quot;&gt;FOUC&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;$(window).on(&#39;polymer-ready&#39;, function() {
  var xfoo = $(&#39;x-foo&#39;)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-5&quot;&gt;公共属性&lt;/h2&gt;

&lt;p&gt;有两种方式申明公共属性&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;polymer-element节点中使用attributes属性 (推荐)&lt;/li&gt;
  &lt;li&gt;polymer构造器中使用publish&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在节点中申明的好处是，一眼就能看出有哪些公共属性。   &lt;br /&gt;
不过当属性很多，需要默认值，以及使用&lt;em&gt;reflect&lt;/em&gt;特性时，使用js的方式还是更方便。&lt;/p&gt;

&lt;p&gt;默认属性是&lt;em&gt;undefined&lt;/em&gt;, 可以使用以下两种方式申明默认值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;polymer-element name=&quot;x-foo&quot; attributes=&quot;bar&quot;&amp;gt;
  &amp;lt;script&amp;gt;
    Polymer({
      bar: false
    })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更简洁的方式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;polymer-element name=&quot;x-foo&quot;&amp;gt;
  &amp;lt;script&amp;gt;
    Polymer({
      publish: {
        bar: false
      }
    })
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;对于属性类型为对象和数组的，需要在created回调方法中设置默认值，以保证每个组件有独立的实例数据&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;polymer-element name=&quot;x-defaults&quot; attributes=&quot;settings&quot;&amp;gt;
  &amp;lt;script&amp;gt;
    Polymer({
      created: function() {
        this.settings = {
          textColor: &#39;blue&#39;
        }
      }
    })
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;property-reflection&quot;&gt;property reflection&lt;/h2&gt;

&lt;p&gt;设置对象属性时，会自动传递到节点&lt;/p&gt;

&lt;p&gt;&lt;code&gt;this.name = &quot;Joe&quot;  --&amp;gt; this.setAttribute(&#39;name&#39;, &#39;Joe&#39;)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;由于双向绑定机制，这个特性大多数情况下用不到，所以默认是关闭的&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;property reflection和双向数据绑定不是一回事&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-6&quot;&gt;数据绑定&lt;/h2&gt;

&lt;p&gt;核心特点，有整整一章介绍哦：）&lt;/p&gt;

&lt;h2 id=&quot;computed-properties&quot;&gt;Computed properties&lt;/h2&gt;

&lt;p&gt;可以使用Polymer Expression来定义属性，这个属性也可以参于Data Binding哦。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;input type=&quot;number&quot; value=&quot;&quot; ...
  &amp;lt;em&amp;gt;^1 = &amp;lt;/em&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
  Polymer({
    num: 2,
    computed: {
      square: &#39;num * num&#39;   //  &amp;lt;-- Polymer Expression
    }
  })
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-7&quot;&gt;申明式事件映射&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;input on-click=&quot;&quot;

&amp;lt;script&amp;gt;
  Polymer({
    buttonClick: function(event, detail, sender) {
    }
  })
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-8&quot;&gt;属性监听&lt;/h2&gt;

&lt;h3 id=&quot;section-9&quot;&gt;基于约定的属性监听机制&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;polymer-element properties=&quot;better&quot;&amp;gt;

  &amp;lt;script&amp;gt;
    Polymer({
      better: &#39;&#39;,
      betterChanged: function(oldValue, newValue) {
      }
    })
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-10&quot;&gt;自定义的属性监听&lt;/h3&gt;

&lt;p&gt;有时候基于约定还搞不定时，需要使用&lt;code&gt;observe&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;Polymer({
  observe {
    foo: &#39;validate&#39;,
    bar: &#39;validate&#39;
  },

  validate: function(oldValue, newValue) {
  }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-11&quot;&gt;自动节点查找&lt;/h2&gt;

&lt;p&gt;有id的dom节点引用，可以通过&lt;code&gt;this.$.id&lt;/code&gt; 引用得到&lt;/p&gt;

&lt;h2 id=&quot;section-12&quot;&gt;自定义事件&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;Polymer({
  onClick: function() {
    this.fire(&#39;ouch&#39;, { ... })
  }
})


$(&#39;ouch-button&#39;).on(&#39;ouch&#39;, function(e) {
  e.type
  e.detail
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-13&quot;&gt;扩展&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;polymer-element name=&quot;polymer-coller&quot; extends=&quot;polymer-cool&quot;&amp;gt;
  &amp;lt;template&amp;gt;
    &amp;lt;shadow&amp;gt;&amp;lt;/shadow&amp;gt;  &amp;lt;!-- 调用父类模板 --&amp;gt;
  &amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用父类的方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;Polymer({
  praise: &#39;cool&#39;,
  makeCoolest: function() {
    this.super()  // 调用父类方法
  }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是如何实现的?  arguments.callee.caller ?&lt;/p&gt;

&lt;h2 id=&quot;section-14&quot;&gt;内置方法&lt;/h2&gt;

&lt;h3 id=&quot;dom&quot;&gt;监听原生dom子节点变化&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;onMutation(element, callback)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-15&quot;&gt;处理异步任务&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Polymer中到处都是异步，变化会先被收集，然后一次性处理，而不是每次都执行。&lt;br /&gt;
  这样就可以进行优化，并且防止重复的工作，并且减少不必要的FOUC&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;this.async(function() {
  this.foo = 3  // this会自动绑定到节点对象
}, null, 1000)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-16&quot;&gt;延迟任务&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;this.responseChanged = function() {
  this.job(&#39;job1&#39;, function() {
    this.fire(&#39;done&#39;)
  }, 5000)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;job可以避免重复操作，类似于我实现的schedule&lt;/p&gt;

&lt;h2 id=&quot;section-17&quot;&gt;高级主题&lt;/h2&gt;

&lt;h3 id=&quot;section-18&quot;&gt;一些方法&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;this.cancelUnbindAll()
unbindAll()
preventDispose
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-19&quot;&gt;数据变化如何传递&lt;/h3&gt;

&lt;p&gt;如果Object.observe()支持，则使用它来监听属性变化&lt;br /&gt;
如果不支持，则使用Platform.flash()来轮询检查变量&lt;/p&gt;

&lt;h3 id=&quot;polymer-element&quot;&gt;Polymer Element如何初始化&lt;/h3&gt;

&lt;p&gt;从性能上考虑，element在created时，如果不在main document内，避免创建ShadowDOM, 进行事件监听，监控属性变化。  &lt;br /&gt;
这在行为上类似原生的img和video&lt;/p&gt;

&lt;p&gt;在以下场景，element将会初始化&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当在main document中创建, document.defaultView存在&lt;/li&gt;
  &lt;li&gt;attached&lt;/li&gt;
  &lt;li&gt;当它的shadowRoot节点被初始化时&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;alwaysPrepare属性可以强制初始化&lt;/p&gt;

&lt;h3 id=&quot;section-20&quot;&gt;路径问题&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;this.resolvePath(x-foo.png)&lt;/code&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 06 Nov 2011 00:00:00 +0800</pubDate>
        <link>http://bencode.github.io/polymer/learning/api-developer-guide.html</link>
        <guid isPermaLink="true">http://bencode.github.io/polymer/learning/api-developer-guide.html</guid>
        
        
        <category>polymer</category>
        
        <category>learning</category>
        
      </item>
    
  </channel>
</rss>
