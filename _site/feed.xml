<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>bencode@编码</title>
    <description></description>
    <link>http://bencode.github.io/</link>
    <atom:link href="http://bencode.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 15 Nov 2014 16:00:26 +0800</pubDate>
    <lastBuildDate>Sat, 15 Nov 2014 16:00:26 +0800</lastBuildDate>
    <generator>Jekyll v2.4.0</generator>
    
      <item>
        <title>［译］Shadow DOM 101</title>
        <description>&lt;p&gt;正在进行中…&lt;/p&gt;
</description>
        <pubDate>Tue, 11 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://bencode.github.io/translation/shadow-dom-101.html</link>
        <guid isPermaLink="true">http://bencode.github.io/translation/shadow-dom-101.html</guid>
        
        
        <category>translation</category>
        
      </item>
    
      <item>
        <title>child_process的同步方法execSync</title>
        <description>&lt;p&gt;node中通过child_processt和shell交互很方便，只是0.10.x版本中的exec没有同步版本，让做“脚本”用途的node写起来很是麻烦。&lt;br /&gt;
而在0.11.12版本后添加了execSync方法解决了这个问题。&lt;/p&gt;

&lt;p&gt;首先node版本要到0.11.12以上才有这个api，可以使用n进行快速安装&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;sudo npm install -g n
n 0.11.14   // 到目前为止，已有0.11.14版了
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后就可以使用了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var exec = require(&#39;child_process&#39;).execSync;
exec(&#39;git log&#39;, { encoding: &#39;utf-8&#39; });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行一下，就发现控制台有git log的输出了 &lt;br /&gt;
上面在options中指定了encoding, 如果不指定，返回的是一个&lt;code&gt;Buffer&lt;/code&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 11 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://bencode.github.io/nodejs/exec-sync.html</link>
        <guid isPermaLink="true">http://bencode.github.io/nodejs/exec-sync.html</guid>
        
        
        <category>nodejs</category>
        
      </item>
    
      <item>
        <title>mruby源码阅读1</title>
        <description>&lt;p&gt;include/mrbconf.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define FALSE 0
define TRUE 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;include/mrb/value.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sun, 09 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://bencode.github.io/codereading/ruby/mruby-01.html</link>
        <guid isPermaLink="true">http://bencode.github.io/codereading/ruby/mruby-01.html</guid>
        
        
        <category>codereading</category>
        
        <category>ruby</category>
        
      </item>
    
      <item>
        <title>Polymer学习笔记 - HTML5 Template</title>
        <description>&lt;p&gt;&lt;a href=&quot;http://www.html5rocks.com/zh/tutorials/webcomponents/template/&quot;&gt;参考资料&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;特性检测&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;function supportTemplate() {
  return &#39;content&#39; in document.createElement(&#39;template&#39;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;声明模板内容&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;template id=&quot;mytemplate&quot;&amp;gt;
  &amp;lt;img src=&quot;&quot; alt=&quot;great image&quot;&amp;gt;
  &amp;lt;div class=&quot;comment&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;特性&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;模板内容在激活前不会被渲染&lt;/li&gt;
  &lt;li&gt;处于模板中的内容无副作用&lt;/li&gt;
  &lt;li&gt;处理模板中的内容不在文档中&lt;/li&gt;
  &lt;li&gt;模板可以放置在任意位置，包括&lt;code&gt;&amp;lt;head&amp;gt;, &amp;lt;body&amp;gt;, &amp;lt;frameset&amp;gt;&lt;/code&gt;&lt;br /&gt;
  并且任何能够出现在以上节点中的内容都可以出现在&lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;中&lt;br /&gt;
  template能够安全地出现在html解析器不允许出现的位置，几乎可以作为任何内容的子节点，如&lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-3&quot;&gt;激活&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var t = document.querySelector(&#39;#mytemplate&#39;)
t.content.querySelector(&#39;img&#39;).src = &#39;logo.png&#39;;

var clone = document.importNode(t.content, true);
document.body.appendChild(clone);
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 08 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://bencode.github.io/reading/polymer/template.html</link>
        <guid isPermaLink="true">http://bencode.github.io/reading/polymer/template.html</guid>
        
        
        <category>reading</category>
        
        <category>polymer</category>
        
      </item>
    
      <item>
        <title>Polymer学习笔记 - Shadow DOM</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;基本使用&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var el = document.createElement(&#39;div&#39;)
var shadow = el.createShadowRoot()
shadow.innerHTML = &#39;&amp;lt;content select=&quot;q&quot;&amp;gt;&amp;lt;/content&amp;gt;&#39;
document.body.appendChild(el)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;subtrees&quot;&gt;subtrees&lt;/h2&gt;

&lt;p&gt;一个节点承载三棵树： light DOM, shadow DOM 和 composed DOM&lt;/p&gt;

&lt;p&gt;组件提供者创建shadow DOM, 使用者提供light DOM， 然后浏览器结合两者成为composed DOM进行渲染。 &lt;br /&gt;
shadow DOM不能被用户访问到，它有自己的空间。 &lt;br /&gt;
这本质上是一种封装和开放，设计上的艺术。&lt;/p&gt;

&lt;h2 id=&quot;polyfill&quot;&gt;Polyfill&lt;/h2&gt;

&lt;p&gt;原生不支持ShadowDom的浏览器，可以使用ShadowDOMPolyfill来包装，只是即使这样，也有若干限制。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;事件重定向&lt;/h3&gt;

&lt;h3 id=&quot;section-2&quot;&gt;已知的缺陷&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;css封装性&lt;/li&gt;
  &lt;li&gt;Object.prototype.toString和原生支持的返回不一致&lt;/li&gt;
  &lt;li&gt;document, window, document.body, document.head等不可配置，不能被重写&lt;/li&gt;
  &lt;li&gt;跨window, frame未实现&lt;/li&gt;
  &lt;li&gt;:host()伪类选择器最多支持1层嵌套的括号选择器&lt;br /&gt;
例：&lt;code&gt;:host(.zot)&lt;/code&gt; and &lt;code&gt;:host(.zot:not(.bar))&lt;/code&gt; 支持, &lt;br /&gt;
  &lt;code&gt;:host(.zot:not(.bar:nth-child(2)))&lt;/code&gt; 不支持&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[资料]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.polymer-project.org/platform/shadow-dom.html&quot;&gt;https://www.polymer-project.org/platform/shadow-dom.html&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://dvcs.w3.org/hg/webcomponents/raw-file/57f8cfc4a7dc/explainer/index.html#shadow-dom-section&quot;&gt;https://dvcs.w3.org/hg/webcomponents/raw-file/57f8cfc4a7dc/explainer/index.html#shadow-dom-section&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/&quot;&gt;http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom-201/&quot;&gt;http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom-201/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom-301/&quot;&gt;http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom-301/&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 08 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://bencode.github.io/reading/polymer/shadow-dom.html</link>
        <guid isPermaLink="true">http://bencode.github.io/reading/polymer/shadow-dom.html</guid>
        
        
        <category>reading</category>
        
        <category>polymer</category>
        
      </item>
    
      <item>
        <title>Polymer学习笔记 - Helper Methods</title>
        <description>&lt;h2 id=&quot;html-imports&quot;&gt;动态Html imports&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;Polymer.import(urls, callback)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&amp;lt;dynamic-element&amp;gt;
  I&#39;m just an unknown element.
&amp;lt;/dynamic-element&amp;gt;

&amp;lt;script&amp;gt;
  var button = document.querySelector(&#39;button&#39;)
  button.addEventListener(&#39;click&#39;, function() {
    Polymer.import([&#39;dynamic-element.html&#39;], function() {
      document.querySelector(&#39;dynamic-element&#39;).description = &#39;a dynamic import&#39;
    })
  });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;mixins&quot;&gt;mixins&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;Polymer.mixin(target, obj1 [, obj2, ..., objN ] )
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section&quot;&gt;强制注册元素&lt;/h2&gt;

&lt;p&gt;默认情况下，Polymer会等待所有元素ready, 再进行注册和更新。 &lt;br /&gt;
如果一个元素没有调用Polymer构造函数，也没有使用noscript属性，则它会一直等待。 &lt;br /&gt;
Polymer.waitingFor帮助方法返回一个阻塞状态的polymer-element列表。  &lt;br /&gt;
Polymer.forceReady通知Polymer强制注册所有已ready的元素，忽略未完成的元素。&lt;/p&gt;
</description>
        <pubDate>Sat, 08 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://bencode.github.io/reading/polymer/helper-methods.html</link>
        <guid isPermaLink="true">http://bencode.github.io/reading/polymer/helper-methods.html</guid>
        
        
        <category>reading</category>
        
        <category>polymer</category>
        
      </item>
    
      <item>
        <title>Polymer学习笔记 - Data Binding</title>
        <description>&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;For Polymer elements, &lt;strong&gt;the model is always the element itself&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;polymer-element name=&quot;name-tag&quot;&amp;gt;
  &amp;lt;template&amp;gt;
    This is &amp;lt;b&amp;gt;{ {owner}}&amp;lt;/b&amp;gt;&#39;s name-tag element.
  &amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;document.querySelector(&#39;name-tag&#39;).owner = &#39;June&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;template&quot;&gt;&amp;lt;template&amp;gt;&lt;/h3&gt;

&lt;p&gt;在Polymer中，使用template定义自定义元素的shadow dom&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;数据绑定和事件处理&lt;/h3&gt;

&lt;p&gt;在事件绑定方法中可以取得事件源节点和模型&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;template repeat=&quot;{ {s in stories}}&quot;&amp;gt;
  &amp;lt;li on-click={ {selectStory}}&amp;gt;{ {s.headline}}&amp;lt;/li&amp;gt;

selectStory: function(e, detail, sender) {
  var story = e.target.templateInstance.model.s
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;types-of-bindings&quot;&gt;Types of bindings&lt;/h2&gt;

&lt;p&gt;有多种绑定数据和模板的方式&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;单模板实例&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;template bind=&quot;{ {person}}&quot;&amp;gt;
    This template can bind to the person object’s properties, like { {name}}.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了方便可以创建&lt;em&gt;name scope&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;template bind=&quot;persion as p&quot;&amp;gt;
  ... like { {p.name}}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;循环模板&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;template repeat=&quot;{ {array}}&quot;&amp;gt;
  Creates an instance with { {}} bindings  for every element in the array collection.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用空表达式&lt;code&gt;{ {}}&lt;/code&gt;表示当前对象&lt;/p&gt;

&lt;p&gt;repeat也支持&lt;em&gt;name scope&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;template repeat=&quot;{ {user, userIndex in users}}&quot;&amp;gt;
  { {user.name}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;repeat可以省略&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;this.items = [
  { name: &#39;Milk&#39; },
  ...
]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;template bind=&quot;{ {item}}&quot;&amp;gt;
  &amp;lt;p&amp;gt;items count: { {length}}
  &amp;lt;template repeat&amp;gt;
    &amp;lt;li&amp;gt;{ {name}}&amp;lt;/li&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;条件模板&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;template if=&quot;{ {conditionalValue}}&quot;&amp;gt;
  Binds if and only if conditionalValue is truthy.
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以混合使用&lt;em&gt;repeat&lt;/em&gt;和&lt;em&gt;if&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;template repeat=&quot;{ {item in list.items}}&quot; if=&quot;{ {list.showItems}}&quot;&amp;gt;
  &amp;lt;li&amp;gt;{ {item.name}}&amp;lt;/li&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-4&quot;&gt;引用模板&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;template id=&quot;myTemplate&quot;&amp;gt;
  这个模板可以被其他地方引用
&amp;lt;/template&amp;gt;

&amp;lt;template bind ref=&quot;myTemplate&quot;&amp;gt;
  这里的内容就忽略啦，使用myTemplate模板内容了
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;node-binding&quot;&gt;Node Binding&lt;/h3&gt;

&lt;p&gt;node binding用于关联节点和模型&lt;/p&gt;

&lt;p&gt;如何绑定依赖于节点类型和绑定名称，绑定名称和绑定在节点中出现的位置有关系&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;textContent 如 &lt;code&gt;&amp;lt;span&amp;gt;{ {someText}}&amp;lt;/span&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;styleName 如 &lt;code&gt;&amp;lt;span style=&quot;{ {someStyles}}&quot;&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-5&quot;&gt;文本绑定&lt;/h4&gt;

&lt;p&gt;出现在节点中间的绑定就是textContent binding&lt;/p&gt;

&lt;p&gt;比如 &lt;code&gt;&amp;lt;p&amp;gt;This paragraph has some { {adjective}} text.&amp;lt;/p&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;textContent绑定是单向的，改变模型，会改变内容, 但反之不会&lt;/p&gt;

&lt;h4 id=&quot;section-6&quot;&gt;属性绑定&lt;/h4&gt;

&lt;p&gt;如何进行属性绑定和节点类型和属性名有关&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;大部分标准dom的属性绑定都是单向的，比如style&lt;/li&gt;
  &lt;li&gt;表单元素，支持双向绑定&lt;/li&gt;
  &lt;li&gt;polymer element的公共属性是支持双向绑定的&lt;/li&gt;
  &lt;li&gt;自定义元素可以实现自己的绑定方式&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-7&quot;&gt;表单元素值的绑定&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;input元素的value和checked&lt;/li&gt;
  &lt;li&gt;options元素的value&lt;/li&gt;
  &lt;li&gt;select元素的selectIndex和value&lt;/li&gt;
  &lt;li&gt;textarea的value&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-8&quot;&gt;条件属性&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;span hidden?=&quot;{ {isHidden}}&quot;&amp;gt;This may or may not be hidden.&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-9&quot;&gt;一次性绑定&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;input type=&quot;text&quot; value=&quot;[[ obj.value ]]&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-10&quot;&gt;表达式&lt;/h2&gt;

&lt;h3 id=&quot;section-11&quot;&gt;行为和限制&lt;/h3&gt;

&lt;p&gt;表达式是javascript的子集&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;表达式用来处理简单的逻辑，不应该把复杂的逻辑放在表达式中&lt;/li&gt;
  &lt;li&gt;表达式从来不是使用eval执行，也不能访问global变量。&lt;/li&gt;
  &lt;li&gt;不能使用表达式插入HTML, 为了防止xss，默认对输出值进行html escape&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-12&quot;&gt;执行&lt;/h3&gt;

&lt;p&gt;表达式可以使用在以下三种情况 &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ {expression}}

[[expression]]

computed: {
  name: expression
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;scope&quot;&gt;上下文(scope)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;bind, repeat, if属性表达式使用的是父模板的作用域&lt;/li&gt;
  &lt;li&gt;最外层模板中表达式和computed属性表达式使用的作用域都是元素本身&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-13&quot;&gt;嵌套作用域规则&lt;/h3&gt;

&lt;p&gt;对于name scope模板，其父作用域是可见的，否则父作用域不可见&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;!-- outermost template -- element&#39;s properties available --&amp;gt;
  &amp;lt;template bind=&quot;{ {organization as organization}}&quot;&amp;gt;
    &amp;lt;!-- organization.* available --&amp;gt;
    &amp;lt;template bind=&quot;{ {organization.contact as contact}}&quot;&amp;gt;
      &amp;lt;!-- organization.* &amp;amp; contact.* available --&amp;gt;
      &amp;lt;template bind=&quot;{ {contact.address}}&quot;&amp;gt;
        &amp;lt;!-- only properties of address are available --&amp;gt;
        &amp;lt;template bind=&quot;{ {streetAddress as streetAddress}}&quot;&amp;gt;
          &amp;lt;!-- streetAddress.* and properties of address are available.
               NOT organization.* or contact.* --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-14&quot;&gt;过滤器&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;{ {user | formatUserName}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的方式，如果user中的字段变化了，表达式不会重新求值,  &lt;br /&gt;
因为表达式不知道应该监听什么属性变化，所以得主动告诉它。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;{ { {firstName: user.firstName, lastName: user.lastName} | formatUserName}}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;tokenlist-styleobject&quot;&gt;tokenList, styleObject&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div class=&quot;{ }&quot;  
&amp;lt;div style=&quot;{ {styles | styleObject}}&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-15&quot;&gt;自定义过滤器&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;Polymer(&#39;greeting-tag&#39;, {
  ...
  toUpperCase: function(value) {
    return value.toUpperCase()
  },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要处理双向绑定的过滤器：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;toUpperCase: {
  toDOM: function(value) {
    return value.toUpperCase()
  },
  toModel: function(value) {
    return value.toLowerCase()
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-16&quot;&gt;过滤器参数&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;{ {myNumber | toFixed(2)}}

toFixed: function(value, precision) {
  return Number(value).toFixed(precision)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;chaining-filter&quot;&gt;chaining filter&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;{ {myNumber | toHex | toUpperCase}}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-17&quot;&gt;自定义全局过滤器&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;PolymerExpressions.prototype.uppercase = function(input) {
  return input.toUpperCase()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;全局过滤器使用html import方式载入&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;link rel=&quot;import&quot; href=&quot;uppercase-filter.html&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-18&quot;&gt;兼容性相关的注意事项&lt;/h2&gt;

&lt;p&gt;不支持template的浏览器，将不支持template节点存在于某些元素里，比如select和table&lt;/p&gt;

&lt;p&gt;Polymer采用变通的方式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;table&amp;gt;
  &amp;lt;tr template repeat=&quot;{ {tr in rows}}&quot;&amp;gt;
    &amp;lt;td&amp;gt;Hello&amp;lt;/td&amp;gt;
  &amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;select的例子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;polymer-element name=&quot;my-select&quot;&amp;gt;
  &amp;lt;template&amp;gt;
    &amp;lt;select&amp;gt;
      &amp;lt;option template repeat=&quot;{ {options}}&quot;&amp;gt;{ {}}&amp;lt;/option&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有些浏览器对属性值中有特殊字符不支持，如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;img src=&quot;/users/{ {id}}.jpg&quot; /&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以在属性前加_&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;img _src=&quot;/users/{ {id}}.jpg&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-19&quot;&gt;数据绑定如何工作&lt;/h2&gt;

&lt;p&gt;Polymer在数据绑定时，不是像传统的ajax那样，会将整片dom进行替换，  &lt;br /&gt;
而是进行&lt;strong&gt;最小的必要的dom变化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;table&amp;gt;
    &amp;lt;template repeat=&quot;{ {item in items}}&quot;&amp;gt;
      &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt; { {item.name}} &amp;lt;/td&amp;gt;&amp;lt;td&amp;gt; { {item.count}} &amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
    &amp;lt;/template&amp;gt;
   &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt; Bass &amp;lt;/td&amp;gt;&amp;lt;td&amp;gt; 7 &amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;  
   &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt; Catfish &amp;lt;/td&amp;gt;&amp;lt;td&amp;gt; 8 &amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt; 
   &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt; Trout &amp;lt;/td&amp;gt;&amp;lt;td&amp;gt; 0 &amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比如现在你对items进行重新排序，polymer不会创建和销毁dom，仅仅也是重新排列一下dom&lt;/p&gt;

&lt;p&gt;如果改变了一个item的count，则只会改变一个td中的值&lt;/p&gt;

&lt;h3 id=&quot;section-20&quot;&gt;数据绑定如何跟踪每个模板实例&lt;/h3&gt;

&lt;p&gt;当模板创建一个或多个实例，它会将实例插入紧跟着模板的位置，并且跟踪每个实例最后节点  &lt;br /&gt;
这样第一个实例就是模板结尾开始到第一个实例结尾，后面的依旧。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;template repeat=&quot;{ {item in myList}}&quot;&amp;gt;
  &amp;lt;img&amp;gt;
  &amp;lt;span&amp;gt;{ {item.name}}&amp;lt;/span&amp;gt;
&amp;lt;/template&amp;gt;                  
  &amp;lt;img&amp;gt;
  &amp;lt;span&amp;gt;foo&amp;lt;/span&amp;gt;   ⇐ terminating node in template instance
  &amp;lt;img&amp;gt;
  &amp;lt;span&amp;gt;bar&amp;lt;/span&amp;gt;   ⇐ terminating node in template instance
  &amp;lt;img&amp;gt;
  &amp;lt;span&amp;gt;baz&amp;lt;/span&amp;gt;   ⇐ terminating node in template instance
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-21&quot;&gt;直接操作模板生成的节点&lt;/h3&gt;

&lt;p&gt;正常情况下，你不应该直接去修改模板生成的dom。 &lt;br /&gt;
非要修改，根据上面的原理，只要不修改最后一个节点，那问题是不大的。 &lt;br /&gt;
所以如果要修改，一般来说嵌套一层，只修改里面的dom节点。 &lt;br /&gt;
但是当修改模型后，修改的dom可能会被替换，因为双向数据绑定只针对于表单域。&lt;/p&gt;

&lt;h2 id=&quot;polymer-element&quot;&gt;在Polymer Element之外使用数据绑定&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;使用auto-binding template&lt;/li&gt;
  &lt;li&gt;可以直接使用&lt;a href=&quot;https://github.com/polymer/TemplateBinding&quot;&gt;TemplateBinding&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;auto-binding-template&quot;&gt;使用auto-binding template可以享有以下特性&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;完整的数据绑定功能&lt;/li&gt;
  &lt;li&gt;声明式事件映射&lt;/li&gt;
  &lt;li&gt;自动节点查找&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;template-binding&quot;&gt;Template Binding&lt;/h2&gt;

&lt;p&gt;Polymer的Template Binding扩展了Html TemplateElement, 让它支持数据绑定的方式来创建，管理和移除内容。&lt;/p&gt;

&lt;p&gt;可以独立使用Template Binding&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;template id=&quot;greeting&quot; bind=&quot;{ { salutations }}&quot;&amp;gt;
  Hello, { {who}} - { {what}}
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
  var t = document.querySelector(&#39;#greeting&#39;)
  var model = {
    salutations: { what: &#39;GoodBye&#39;, who: &#39;Imperative&#39; }
  }
  t.model = model   // &amp;lt;-- 设置模型
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;nodebind&quot;&gt;Node.bind()&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/polymer/NodeBind&quot;&gt;Node.bind&lt;/a&gt; 用于数据绑定，可以将节点绑定到数据属性，它也可以独立的使用&lt;/p&gt;

&lt;h3 id=&quot;section-22&quot;&gt;基本使用&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var obj = {
  path: {
    to: {
      value: &#39;hi&#39;
    }
  }
}

var textNode = document.createTextNode(&#39;mytext&#39;)
textNode.bind(&#39;textContent&#39;, new PathObserver(obj, &#39;path.to.value&#39;))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-23&quot;&gt;绑定类型&lt;/h3&gt;

&lt;p&gt;以下类型可以进行双向绑定&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Text node - textContent&lt;/li&gt;
  &lt;li&gt;HtmlInputElement - value &amp;amp; checked&lt;/li&gt;
  &lt;li&gt;HtmlTextareaElement - value&lt;/li&gt;
  &lt;li&gt;HtmlSelectElement - value 和 selectedIndex&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以其他的都绑定到元素属性&lt;/p&gt;

&lt;h3 id=&quot;section-24&quot;&gt;自定义元素的绑定&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;MyFancyHTMLWidget.prototype.bind = function(name, observable, oneTime) {
  if (name == &#39;myBinding&#39;) {
    // interpret the binding meaning
    // if oneTime is false, this should return an object which
    // has a close() method.
    // this will allow TemplateBinding to clean up this binding
    // when the instance containing it is removed.
  } else {
    return HTMLElement.prototype.bind.call(
      this, name, observable, oneTime
    )
  }
}
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Fri, 07 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://bencode.github.io/reading/polymer/data-binding.html</link>
        <guid isPermaLink="true">http://bencode.github.io/reading/polymer/data-binding.html</guid>
        
        
        <category>reading</category>
        
        <category>polymer</category>
        
      </item>
    
      <item>
        <title>Polymer学习笔记 - API Developer Guide</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://www.polymer-project.org/docs/polymer/polymer.html&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;help make developing web components much easier&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;声明&lt;/h2&gt;

&lt;p&gt;使用&lt;code&gt;&amp;lt;polymer-element&amp;gt;&lt;/code&gt;声明组件&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;属性&lt;/h2&gt;

&lt;p&gt;有一些保留的attributes用于描述组件  &lt;br /&gt;
如：&lt;em&gt;name, attributes, extends, noscript, constractor&lt;/em&gt;&lt;br /&gt;
其他的属性将会自动应用到组件  &lt;br /&gt;
属性名的大小写是无关紧要的，polymer会聪明地应用到实际对象上&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;注册&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;Polymer(tag-name, prototype)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;custom-element-prototype-chain&quot;&gt;Custom element prototype chain&lt;/h2&gt;

&lt;p&gt;Polymer对象属性和方法的继承链：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;prototype对象中定义的属性和方法&lt;/li&gt;
  &lt;li&gt;Polymer定义的基本属性和方法&lt;/li&gt;
  &lt;li&gt;HTML Element的属性和方法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以为了避免冲突，请不要定义&lt;em&gt;id, children, focus, title, hidden&lt;/em&gt;等属性和方法&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;结果不可预料 ？ &amp;lt;－－ 文档中是这么说的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-3&quot;&gt;属性的引用&lt;/h2&gt;

&lt;p&gt;在模板中 &lt;code&gt;$.globals.firstName&lt;/code&gt;  &lt;br /&gt;
在js中 &lt;code&gt;this.$.globals.firstName&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;生命周期&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;{
  created: function() {},  
  ready: function() {},  
  attached: function() {},
  domReady: function() {},  
  detached: function() {},  
  attributeChanged: function(name, oldValue, newValue) {}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;polymer-ready&quot;&gt;polymer-ready&lt;/h2&gt;

&lt;p&gt;polymer解析定义，更新以及载入资源都是异步的，所以需要一个类似domready的事件来防止&lt;a href=&quot;http://en.wikipedia.org/wiki/Flash_of_unstyled_content&quot;&gt;FOUC&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;$(window).on(&#39;polymer-ready&#39;, function() {
  var xfoo = $(&#39;x-foo&#39;)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-5&quot;&gt;公共属性&lt;/h2&gt;

&lt;p&gt;有两种方式声明公共属性&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;polymer-element节点中使用attributes属性 (推荐)&lt;/li&gt;
  &lt;li&gt;polymer构造器中使用publish&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在节点中声明的好处是，一眼就能看出有哪些公共属性。   &lt;br /&gt;
不过当属性很多，需要默认值，以及使用&lt;em&gt;reflect&lt;/em&gt;特性时，使用js的方式还是更方便。&lt;/p&gt;

&lt;p&gt;默认属性是&lt;em&gt;undefined&lt;/em&gt;, 可以使用以下两种方式声明默认值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;polymer-element name=&quot;x-foo&quot; attributes=&quot;bar&quot;&amp;gt;
  &amp;lt;script&amp;gt;
    Polymer({
      bar: false
    })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更简洁的方式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;polymer-element name=&quot;x-foo&quot;&amp;gt;
  &amp;lt;script&amp;gt;
    Polymer({
      publish: {
        bar: false
      }
    })
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;对于属性类型为对象和数组的，需要在created回调方法中设置默认值，以保证每个组件有独立的实例数据&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;polymer-element name=&quot;x-defaults&quot; attributes=&quot;settings&quot;&amp;gt;
  &amp;lt;script&amp;gt;
    Polymer({
      created: function() {
        this.settings = {
          textColor: &#39;blue&#39;
        }
      }
    })
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;property-reflection&quot;&gt;property reflection&lt;/h2&gt;

&lt;p&gt;设置对象属性时，会自动传递到节点&lt;/p&gt;

&lt;p&gt;&lt;code&gt;this.name = &quot;Joe&quot;  --&amp;gt; this.setAttribute(&#39;name&#39;, &#39;Joe&#39;)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;由于双向绑定机制，这个特性大多数情况下用不到，所以默认是关闭的&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;property reflection和双向数据绑定不是一回事&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-6&quot;&gt;数据绑定&lt;/h2&gt;

&lt;p&gt;核心特点，有整整一章介绍哦：）&lt;/p&gt;

&lt;h2 id=&quot;computed-properties&quot;&gt;Computed properties&lt;/h2&gt;

&lt;p&gt;可以使用Polymer Expression来定义属性，这个属性也可以参于Data Binding哦。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;input type=&quot;number&quot; value=&quot;{ {num}}&quot; ...
  &amp;lt;em&amp;gt;{ {num}}^1 = { {square}}&amp;lt;/em&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
  Polymer({
    num: 2,
    computed: {
      square: &#39;num * num&#39;   //  &amp;lt;-- Polymer Expression
    }
  })
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-7&quot;&gt;声明式事件映射&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;input on-click=&quot;{ {buttonClick}}&quot;

&amp;lt;script&amp;gt;
  Polymer({
    buttonClick: function(event, detail, sender) {
    }
  })
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-8&quot;&gt;属性监听&lt;/h2&gt;

&lt;h3 id=&quot;section-9&quot;&gt;基于约定的属性监听机制&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;polymer-element properties=&quot;better&quot;&amp;gt;

  &amp;lt;script&amp;gt;
    Polymer({
      better: &#39;&#39;,
      betterChanged: function(oldValue, newValue) {
      }
    })
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-10&quot;&gt;自定义的属性监听&lt;/h3&gt;

&lt;p&gt;有时候基于约定还搞不定时，需要使用&lt;code&gt;observe&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;Polymer({
  observe {
    foo: &#39;validate&#39;,
    bar: &#39;validate&#39;
  },

  validate: function(oldValue, newValue) {
  }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-11&quot;&gt;自动节点查找&lt;/h2&gt;

&lt;p&gt;有id的dom节点引用，可以通过&lt;code&gt;this.$.id&lt;/code&gt; 引用得到&lt;/p&gt;

&lt;h2 id=&quot;section-12&quot;&gt;自定义事件&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;Polymer({
  onClick: function() {
    this.fire(&#39;ouch&#39;, { ... })
  }
})


$(&#39;ouch-button&#39;).on(&#39;ouch&#39;, function(e) {
  e.type
  e.detail
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-13&quot;&gt;扩展&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;polymer-element name=&quot;polymer-coller&quot; extends=&quot;polymer-cool&quot;&amp;gt;
  &amp;lt;template&amp;gt;
    &amp;lt;shadow&amp;gt;&amp;lt;/shadow&amp;gt;  &amp;lt;!-- 调用父类模板 --&amp;gt;
  &amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用父类的方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;Polymer({
  praise: &#39;cool&#39;,
  makeCoolest: function() {
    this.super()  // 调用父类方法
  }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是如何实现的?  arguments.callee.caller ?&lt;/p&gt;

&lt;h2 id=&quot;section-14&quot;&gt;内置方法&lt;/h2&gt;

&lt;h3 id=&quot;dom&quot;&gt;监听原生dom子节点变化&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;onMutation(element, callback)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-15&quot;&gt;处理异步任务&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Polymer中到处都是异步，变化会先被收集，然后一次性处理，而不是每次都执行。&lt;br /&gt;
  这样就可以进行优化，并且防止重复的工作，并且减少不必要的FOUC&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;this.async(function() {
  this.foo = 3  // this会自动绑定到节点对象
}, null, 1000)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-16&quot;&gt;延迟任务&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;this.responseChanged = function() {
  this.job(&#39;job1&#39;, function() {
    this.fire(&#39;done&#39;)
  }, 5000)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;job可以避免重复操作，类似于我实现的schedule&lt;/p&gt;

&lt;h2 id=&quot;section-17&quot;&gt;高级主题&lt;/h2&gt;

&lt;h3 id=&quot;section-18&quot;&gt;一些方法&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;this.cancelUnbindAll()
unbindAll()
preventDispose
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-19&quot;&gt;数据变化如何传递&lt;/h3&gt;

&lt;p&gt;如果Object.observe()支持，则使用它来监听属性变化&lt;br /&gt;
如果不支持，则使用Platform.flash()来轮询检查变量&lt;/p&gt;

&lt;h3 id=&quot;polymer-element&quot;&gt;Polymer Element如何初始化&lt;/h3&gt;

&lt;p&gt;从性能上考虑，element在created时，如果不在main document内，避免创建ShadowDOM, 进行事件监听，监控属性变化。  &lt;br /&gt;
这在行为上类似原生的img和video&lt;/p&gt;

&lt;p&gt;在以下场景，element将会初始化&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当在main document中创建, document.defaultView存在&lt;/li&gt;
  &lt;li&gt;attached&lt;/li&gt;
  &lt;li&gt;当它的shadowRoot节点被初始化时&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;alwaysPrepare属性可以强制初始化&lt;/p&gt;

&lt;h3 id=&quot;section-20&quot;&gt;路径问题&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;this.resolvePath(x-foo.png)&lt;/code&gt;&lt;/p&gt;

</description>
        <pubDate>Thu, 06 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://bencode.github.io/reading/polymer/api-developer-guide.html</link>
        <guid isPermaLink="true">http://bencode.github.io/reading/polymer/api-developer-guide.html</guid>
        
        
        <category>reading</category>
        
        <category>polymer</category>
        
      </item>
    
      <item>
        <title>AOP及其在Javascript中的应用</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;两个例子&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;示例1&lt;/h3&gt;

&lt;p&gt;旺铺中有一些前端的方法，提供APP，模板，自定义样式的基本功能&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// 用于应用模板
TemplateService.apply(template)

// 应用自定义样式
CustomStyleService.apply(subject, data);

// 用于添加，载入，编辑，删除app
AppService.load(app)
AppService.edit(app)
AppService.del(app)
AppService.add(app)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有一个需求是：这些操作成功后，需要打个点&lt;/p&gt;

&lt;p&gt;我们知道直接在这些实现中打点是不适合适的，因为打点不是这些功能“应有的逻辑”，而是“附加”的逻辑&lt;/p&gt;

&lt;p&gt;一种不错的的方法是使用事件，比如旺铺以上这些操作都对应于事件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;page-template-apply
page-custom-style-update

app-load
app-save
app-delete
app.add
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打点实现&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;site.on(&#39;page-template-apply&#39;, function() {
  doTrace(&#39;...&#39;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，原先我们可能需要在基础代码中进行打点，而现在通过一个observer “倒置”了依赖，让打点依赖于这些事件&lt;/p&gt;

&lt;p&gt;再看另一种“邪恶”一点的实现, 我们直接看一下代码&lt;/p&gt;

&lt;p&gt;在template-service.js中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var TemplateService = {
  apply: function() {
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在另一个打点文件中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var _apply = TemplateService.apply;
TemplateService.apply = function() {
  var defer = _apply.apply(this, arguments);
  defer.done(function() {
    doTrace();	// 应用成功后我们打个点
  });
  return defer;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对第二种情况分析下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;原来的模块不需要依赖业务模块，还是那么干净，而且如果单为实现这个功能，连事件都不需要&lt;/li&gt;
  &lt;li&gt;写以上代码时，你会感觉有点害怕&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-2&quot;&gt;示例2&lt;/h3&gt;

&lt;p&gt;有时候我们需要对一些第三方库fix，比如我们对Number#toFixed进行一些修改以支持价格展示&lt;/p&gt;

&lt;p&gt;比如旺铺中为了更好地规划jQuery的构造，context不能为空&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var node = $(&#39;div.panel&#39;, context);
var node = $(&#39;.panel&#39;);   // 在开发时应该提示一些警告，说最好带上tag以及context
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;if (may.log.isEnabled(&#39;info&#39;)) {

  var orijQuery = jQuery,
    ...;

  jQuery = function(selector, context) {
    if (typeof selector === &#39;string&#39; &amp;amp;&amp;amp; 
        selector !== &#39;body&#39; &amp;amp;&amp;amp;
        !/^\s*&amp;lt;/.test(selector) &amp;amp;&amp;amp; 
        !/^#/.test(selector)) {

      if (context === undefined) {
        warn(&#39;please specify context for &#39;+ selector + &#39; in &#39;, 
            arguments.callee.caller);
      }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们在日志级别为info时疯狂了一把,&lt;br /&gt;
然后开发时代码就会帮我们检查了。&lt;/p&gt;

&lt;p&gt;总结：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在方法执行后执行一段逻辑&lt;/li&gt;
  &lt;li&gt;重写方法，执行自己的逻辑&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-3&quot;&gt;词汇&lt;/h2&gt;

&lt;p&gt;连接点(join point)&lt;br /&gt;
切入点(pointcut)&lt;br /&gt;
通知(Advice)&lt;br /&gt;
Aspect&lt;br /&gt;
编织(weaving)&lt;/p&gt;

&lt;h2 id=&quot;aspect&quot;&gt;Aspect模块简介&lt;/h2&gt;

&lt;p&gt;静态方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;Aspect.before(target, pointcut, advice)
Aspect.after(target, pointcut, advice)
Aspect.around(target, pointcut, advice)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实例方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;Aspect#before(target, pointcut, advice)
Aspect#after(target, pointcut, advice)
Aspect#around(target, pointcut, advice)

Aspect#attach()
Aspect#detach()

Aspect#isDetached
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-4&quot;&gt;实践&lt;/h2&gt;

&lt;h3 id=&quot;section-5&quot;&gt;示例1&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;define(&#39;demo.Page&#39;, [&#39;jQuery&#39;, &#39;Log&#39;, &#39;lang.Aspect&#39;, &#39;ui.Dialog&#39;], 

function($, Log, Aspect, Dialog) {


var log = new Log(&#39;demo.Page&#39;);

var aspect = new Aspect();
  
return {
  init: function(div) {
    var self = this;
    div.on(&#39;click&#39;, &#39;a[data-action]&#39;, function(e) {
      e.preventDefault();

      var action = $(this).data(&#39;action&#39;);
      log.info(action)
      self[action]();
    });
  },

  onAlert: function() {
    alert(&#39;Hello&#39;);
  },

  onBefore: function() {
    aspect.before(window, &#39;alert&#39;, function(o) {
      var title = o.args[0];
      return [&#39;Before &#39; + title];
    });
  },

  onAfter: function() {
    aspect.after(window, &#39;alert&#39;, function(o) {
      var _alert = o.method;	
      _alert(o.args[0] + &#39; After&#39;);
    });
  },

  onAround: function() {
    aspect.around(window, &#39;alert&#39;, function(o) {
      Dialog.info(o.args[0]);
    });
  },

  onAttach: function() {
    aspect.attach();
  },

  onDetach: function() {
    aspect.detach();
  }

};
  
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-6&quot;&gt;示例2&lt;/h3&gt;

&lt;p&gt;HtmlParser结构&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var HtmlParser = {
  parse: function(),
  parseNode: function(),
  parseComment: function(),
  parseElement: function(),
  parseTag: function(),
  parseAttribute: function(),
  parseText: function()...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Visitor结构&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var Visitor = {
  visitNode: function(node) {
    console.debug(node);
  },

  visitComment: function(comment) {
    console.debug(comment);
  },

  visitElement: function(elm) {
    console.debug(elm);
  },

  visitTag: function(tag) {
    console.debug(tag);
  },

  visitAttribute: function(attr) {
    console.debug(attr);
  },

  visitText: function(text) {
    console.debug(text);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;parse和parseWithVisit&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;  init: function(div) {
    $(&#39;a.parse&#39;, div).on(&#39;click&#39;, $.proxy(this, &#39;parse&#39;));
    $(&#39;a.parse-with-visit&#39;, div).on(&#39;click&#39;, $.proxy(this, &#39;parseWithVisit&#39;));

    this.text = $(&#39;textarea.html-text&#39;, div);
  },

  parse: function() {
    var parser = new HtmlParser(this.text.val());
    var o = parser.parse();
    console.debug(o);
  },

  parseWithVisit: function() {
    var parser = new HtmlParser(this.text.val());
    
    this.weave(parser);
    
    parser.parse();
  },

  weave: function(parser) {
    Aspect.after(parser, /^parse\w+/, function(o) {
      var name = o.name,
        visitName = &#39;visit&#39; + /^parse(\w+)$/.exec(name)[1];
      
      Visitor[visitName] &amp;amp;&amp;amp; Visitor[visitName](o.result);
    });
  }

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-7&quot;&gt;注意&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;OOP 和 AOP &lt;/p&gt;

    &lt;p&gt;OOP: 处理核心逻辑&lt;/p&gt;

    &lt;p&gt;AOP： 处理切面逻辑&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;执行流程比较难理解&lt;/li&gt;
  &lt;li&gt;破坏了封装性&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 26 Dec 2012 00:00:00 +0800</pubDate>
        <link>http://bencode.github.io/javascript/aop-practice.html</link>
        <guid isPermaLink="true">http://bencode.github.io/javascript/aop-practice.html</guid>
        
        
        <category>javascript</category>
        
      </item>
    
      <item>
        <title>Inside jQuery</title>
        <description>&lt;h3 id=&quot;jqueryfninit--99&quot;&gt;jQuery.fn.init处理流程  [99]&lt;/h3&gt;

&lt;p&gt;构造jQuery对象时，会转交给jQuery.fn.init处理。所以先看看它的处理流程, 就能够知道有几种方式调用jQuery方法，也知道内部的一些细节。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;1. $(dom)
  this.context = this[0] = dom
  this.length = 1;
  return this;


2. $(&#39;body&#39;) 
  this[0] = document.body
  this.length = 1;
  return this;


3. $(html)
  细节点: 下面两者等效，即会过滤前后非tag内容
  $(&#39;1212&amp;lt;div&amp;gt;...&amp;lt;/div&amp;gt;dfdf&#39;) -&amp;gt; $(&#39;&amp;lt;div&amp;gt;...&amp;lt;/div&amp;gt;&#39;)

  1. single tag: &#39;&amp;lt;div&amp;gt;&#39;, &#39;&amp;lt;div /&amp;gt;&#39;, &#39;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&#39;
    1. document.createElement

    2? $(&#39;&amp;lt;a&amp;gt;&#39;, {
        id: &#39;mydiv&#39;,
        href: &#39;...&#39;,
        target: &#39;_blank&#39;
      })
        
      jQuery.fn.attr.call(elm, attrs)

  2. else 
    jQuery.buildFragment

4. $(&#39;#id&#39;)
  document.getElementById

5. $(selector) -&amp;gt; $(document).find(selector)
   $(selector, jq) -&amp;gt; jq.find(selector)
   $(selector, context) -&amp;gt; $(context).find(selector) 


7. $(function) -&amp;gt; $(document).ready(function)


8. $(jq) -&amp;gt; 创建一个新的jq对象
  this.selector = jq.selector
  this.context = jq.context
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;thiscontextthisselector&quot;&gt;关于this.context和this.selector&lt;/h3&gt;

&lt;p&gt;context是jQuery对象的一个属性值, 一般情况下不需要知道它是什么， 但要深刻理解冒泡事件，就要知道它的值，现在仅列一下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. $(!selector)
  context: undefined

2. $(dom)
  context: dom

3. $(&#39;body&#39;)
  context: document
  selector = &#39;body&#39;

4. $(html)
  context = undefined
  selector = &#39;&#39;
  
5. $(&#39;#id&#39;)
  context = document
  selector: selector
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;core&quot;&gt;core&lt;/h3&gt;

&lt;p&gt;一些方法的备注&lt;/p&gt;

&lt;h4 id=&quot;get---toarray&quot;&gt;1. get() -&amp;gt; toArray()&lt;/h4&gt;
&lt;p&gt;无参数调用get,返回原生节点数组&lt;/p&gt;

&lt;h4 id=&quot;end---thisprevobject--null&quot;&gt;2. end() -&amp;gt; this.prevObject || $(null)&lt;/h4&gt;
&lt;p&gt;调用end()返回this.prevObject或空的jQuery对象&lt;/p&gt;

&lt;p&gt;关于prevObject看下面jQuery对象结构图&lt;/p&gt;

&lt;h4 id=&quot;pushstack&quot;&gt;3. pushStack&lt;/h4&gt;

&lt;p&gt;会生成一个新的jQuery对象, 并设置prevObject指向当前jQuery对象，返回生成的jQuery对象。&lt;br /&gt;
jquery方法中，如果是生成一个新的jQuery对象，一般会调用pushStack构造新的对象，如 find, slice等。&lt;/p&gt;

&lt;p&gt;熟悉以下对象结构图，有助于更好地理解jQuery, 也能知道和评估它的成本&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/inside-jquery/01.png&quot; alt=&quot;jQuery对象结构图&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;extend&quot;&gt;extend&lt;/h3&gt;

&lt;p&gt;这个方法太常用了，也太好用了， 有些边界情况记录一下&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;1. 只有一个参数的情况，表示添加到当前对象&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;$.extend({...}) -&amp;gt; $.extend($, {...})
$.fn.extend({...}) -&amp;gt; $.extend($.fn, {...})
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;nullundefined&quot;&gt;2. null/undefined的参数将会忽略&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;$.extend({}, { number: 123 }, null, { other: &#39;me&#39; });
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;undefined&quot;&gt;3. undefined的字段将会忽略&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;$.extend({}, { a: 123, b: undefined });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果中并不包含b字段，&lt;strong&gt;注：null字段还会存在的&lt;/strong&gt;，当然使用时不要太依赖这边边界。&lt;/p&gt;

&lt;h4 id=&quot;arrayindex&quot;&gt;4. 参数类型为array时，将依据index进行合并&lt;/h4&gt;

&lt;p&gt;这个特性其实不是很好，可能会产生误解&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;$.extend(true, { a: [1, 2, 3] }, { a: [2, 3] });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果为 { a: [2, 3, 3] }, 不是 { a: [1, 2, 3, 2, 3] } 哦 &lt;/p&gt;

&lt;h3 id=&quot;holdready----from-jquery16&quot;&gt;holdReady – from jquery1.6&lt;/h3&gt;

&lt;p&gt;延迟domready的执行, 做性能优化的同学可以考虑这个方法的使用场景&lt;/p&gt;

&lt;h3 id=&quot;domready&quot;&gt;domready&lt;/h3&gt;

&lt;p&gt;下面是domready的原理&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;先检查document.readyState === ‘complete’&lt;/li&gt;
  &lt;li&gt;标准浏览器&lt;br /&gt;
 document.addEventListener(‘DOMContextLoaded’,&lt;br /&gt;
 保险起见, 再注册&lt;br /&gt;
 window.addEventListener(‘load’,&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;IE&lt;br /&gt;
 document.attachEvent(‘onreadystatechange’,&lt;br /&gt;
 保险起见, 再注册&lt;br /&gt;
 window.attachEvent(‘onload’,&lt;/p&gt;

    &lt;p&gt;// 在IE下，如果非iframe, 则可做一定优化&lt;br /&gt;
 document.documentElement.doScroll(‘left’)可调用, 则dom肯定ready了&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;type-&quot;&gt;$.type 用于查看某个对象的类型&lt;/h3&gt;

&lt;p&gt;原理: &lt;br /&gt;
toString.call(obj) –&amp;gt; 再查表&lt;/p&gt;

&lt;h3 id=&quot;isarray-isplainobject&quot;&gt;$.isArray, $.isPlainObject&lt;/h3&gt;
&lt;p&gt;jQuery提供的类型判断中，最常用的有以上两个，其他的直接使用typeof 都能搞定&lt;/p&gt;

&lt;h3 id=&quot;parsejson&quot;&gt;parseJSON&lt;/h3&gt;

&lt;p&gt;实现中：原生支持使用原生，否则创建一个Function运行&lt;br /&gt;
1. window.JSON&lt;br /&gt;
2. new Function(…)();&lt;/p&gt;

&lt;h3 id=&quot;noop-&quot;&gt;noop 空操作函数引用&lt;/h3&gt;
&lt;p&gt;用这个可以减少每次空函数产生的内存&lt;/p&gt;

&lt;h3 id=&quot;globaleval&quot;&gt;globalEval&lt;/h3&gt;

&lt;p&gt;实现方案：如果存在window.execScript则使用它执行否则使用eval&lt;br /&gt;
1. window.execScript&lt;br /&gt;
2. eval&lt;/p&gt;

&lt;h3 id=&quot;each&quot;&gt;each&lt;/h3&gt;
&lt;p&gt;return false 相当于break&lt;/p&gt;

&lt;h3 id=&quot;trim&quot;&gt;trim&lt;/h3&gt;

&lt;p&gt;原生支持的话使用原生，否则使用正则式, 注意正则式技巧&lt;br /&gt;
1. string#trim&lt;br /&gt;
2. 用两个正则式分别replace前后两段空白&lt;/p&gt;

&lt;h3 id=&quot;inarray&quot;&gt;inArray&lt;/h3&gt;

&lt;p&gt;实现中：如果原生支持indexOf则直接使用, 否则自己处理&lt;br /&gt;
1. array.indexOf&lt;br /&gt;
2. … &lt;/p&gt;

&lt;h3 id=&quot;grep&quot;&gt;grep&lt;/h3&gt;
&lt;p&gt;支持第3个参数inv, 即选出callback为false的元素&lt;/p&gt;

&lt;h3 id=&quot;map&quot;&gt;map&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;如果返回值为null/undefined，则不被添加到集合中&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;$.map([1, 2, 3], function(v) { return v === 2 ? null : 2 * v  });
[2, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;如果返回值是个数组，则“打散”后再添加到集合中&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;$.map([1, 2, 3], function(v) { return [1, 2, 3] });
[1, 2, 3, 1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;proxyfn-context-&quot;&gt;proxy(fn, context, …)&lt;/h3&gt;

&lt;p&gt;这个方法常常被我用于“减少缩进”&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var A = {
  init: function() {
    var self = this;
    $.ajax(url, {
      data: ...
      success: $.proxy(self, &#39;success&#39;);
    });	
  },

  success: function() {
    ...
    this.render();
  },

  render: ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;前面这种形式的调用相当于… &lt;br /&gt;
proxy(object, ‘name’) —&amp;gt; proxy(object[name], object)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可传递额外的参数&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var f = function(num, e) {
	e.preventDefault();
	console.debug(num);
}; 

btn1.click($.proxy(f, 123));
btn2.click($.proxy(f, 456));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;额外参数会加到前面哦&lt;/p&gt;

&lt;h3 id=&quot;access&quot;&gt;access&lt;/h3&gt;
&lt;p&gt;这个方法在jQuery内部使用, 当需要设置/获取属性时&lt;br /&gt;
 如： attr, css, prop, val等将会统一调用access， 所以这些个方法会有一致行为&lt;/p&gt;

&lt;h3 id=&quot;callbacks&quot;&gt;Callbacks&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;jquery1.7提供，用于统一callback list的使用。如jq内部的Deferred使用了Callbacks&lt;br /&gt;
可以使用它方便observer等模式的书写。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var A = {
  
  init: function() {
    this.fire(1, 2, 3);
  }
    
};
$.extend(A, $.Callbacks());


A.add(function() {
  console.debug(&#39;a&#39;, arguments);
});
A.add(function() {
  console.debug(&#39;b&#39;, arguments); 
});

A.init();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2 callbacks对象的add/remove/fire等等方法支持detach的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;add = callbacks.add;
add(); // 这样是能够正常使用的
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以以上例子可以更改为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var B = {
  init: function() {
    this.publish(1, 2, 3);
  }
};
var proxy = $.Callbacks();
$.extend(B, {
  publish: proxy.fire,
  subscribe: proxy.add
});

B.subscribe(function() {
  console.debug(&#39;a&#39;, arguments); 
});
B.subscribe(function() {
  console.debug(&#39;b&#39;, arguments);  
});
B.init();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样仅向B暴露需要的方法&lt;/p&gt;

&lt;p&gt;3 可以构造不同类型(行为)的Callbacks，目前有 once memory stopOnFalse unique, 他们可以组合使用&lt;br /&gt;
  具体可以参看文档：http://api.jquery.com/jQuery.Callbacks&lt;/p&gt;

&lt;h3 id=&quot;deferred&quot;&gt;Deferred&lt;/h3&gt;

&lt;p&gt;根据 http://wiki.commonjs.org/wiki/Promises/A 引入一种更好的方式来管理回调方法的使用&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;1 参数中添加回调&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;//正常用法
$.ajax(&#39;mock.php&#39;, {
  dataType: &#39;jsonp&#39;,
  success: function(o) {
    console.debug(o); 
  } 
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;promise&quot;&gt;2 使用promise接口&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var o = $.ajax(&#39;mock.php&#39;, { dataType: &#39;jsonp&#39; });

o.done(function(o) {
  console.debug(&#39;success1&#39;, o); 
});

o.done(function(o) {
  console.debug(&#39;success2&#39;, o); 
});


var o = $.ajax(&#39;error.php&#39;, { dataType: &#39;jsonp&#39; });
o.fail(function(e) {
  console.debug(&#39;error&#39;, e); 
});
o.always(function() {
  console.debug(&#39;complete&#39;); 
});


var o = $.ajax(&#39;mock.php&#39;, { dataType: &#39;jsonp&#39; });
o.then(function() {
  console.debug(&#39;success&#39;);
}, function() {
  console.debug(&#39;error&#39;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;when-&quot;&gt;3 使用$.when, 当几个并行任务运行完毕&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var url = &#39;mock.php&#39;,
  a1 = $.ajax(url, { dataType: &#39;jsonp&#39; }),
  a2 = $.ajax(url, { dataType: &#39;jsonp&#39; }),
  a3 = $.ajax(url, { dataType: &#39;jsonp&#39; });

$.when(a1, a2, a3).done(function() {
  console.debug(&#39;all complete&#39;);  
});
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var urls = [...],
  promise = $.when($.map(urls, function(url) {
    return $.ajax(url, { dataType: &#39;script&#39;, cache: false });	
  }));

promise.done(function() {
    
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;pipe&quot;&gt;4.使用pipe，几个任务需要串行运行&lt;/h4&gt;

&lt;p&gt;第二个请求依赖第一个请求，要完成后才能发&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var request = $.ajax(&#39;mock.php&#39;, { dataType: &#39;jsonp&#39; }),
  chained = request.pipe(function(o) {
    return $.ajax(&#39;mock&#39;, { dataType: &#39;jsonp&#39;, data: { o: o.data } }); 
  });

chained.done(function(o) {
  console.debug(o); 
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这么多请求顺序发, 因为后者使用到前者数据&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var urls = [
  &#39;mock.php&#39;,
  &#39;mock.php&#39;,
  &#39;mock.php&#39;,
  &#39;mock.php&#39;
];

var promise = $.when();
$.each(urls, function(index, url) {
  promise = promise.pipe(function(o) {
    return $.ajax(url, { 
      dataType: &#39;jsonp&#39;, 
      data: { index: index, o: o &amp;amp;&amp;amp; o.data } 
    });
  });
});
promise.done(function(o) {
  console.debug(&#39;all complete&#39;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;deferred-1&quot;&gt;5 使用Deferred&lt;/h4&gt;

&lt;p&gt;如何等待几个任务运行完毕，而又分离任务，让他们互不依赖&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var CountDown = function(promise) {
  var span = $(&#39;span.countdown&#39;),
    num = 15,
    render = function() {
      span.text(num);
      if (num === 0) {
        promise.resolve();
      } else {
        setTimeout(render, 1000);
      }
      num--;
    };

  render();
};


var RemoteHtml = function(promise) {
  var div = $(&#39;div.remote-html&#39;);
  div.html(&#39;loading...&#39;);

  $.ajax(&#39;remote-html.php&#39;).done(function(html) {
    div.html(html);
    promise.resolve();
  });
};


var ClickMe = function(promise) {
  var btn = $(&#39;input.click-me&#39;),
    num = 10;
  btn.val(num);

  btn.on(&#39;click&#39;, function() {
    num--;
    if (num &amp;gt;=0) {
      btn.val(num);
      if (num === 0) {
        promise.resolve();  
      }
    }
  });
};


var tasks = [CountDown, RemoteHtml, ClickMe];
$.when.apply($, $.map(tasks, function(task) {
  return $.Deferred(task);  
})).done(function() {
  alert(&#39;全部干完了&#39;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;data&quot;&gt;data&lt;/h3&gt;

&lt;h4 id=&quot;data-&quot;&gt;data 数据结构&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div id=&quot;mydiv1&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;div id=&quot;mydiv2&quot;&amp;gt;&amp;lt;/div&amp;gt;

&amp;lt;script&amp;gt;
$(&#39;#mydiv1&#39;).data(&#39;someData1&#39;, &#39;some data 1 value&#39;);
$(&#39;#mydiv1&#39;).data(&#39;some-data-2&#39;, { name: &#39;hello&#39; });

$(&#39;#mydiv2&#39;).data(&#39;someData3&#39;, [1, 2, 3]);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/assets/inside-jquery/02.png&quot; alt=&quot;data数据结构&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们用户的数据存在名叫data的域中，jQuery内部很多地方使用了这个jQuery.cache。&lt;br /&gt;
如queue, event(下面会讲), 以及其他方法中的一些标识。&lt;br /&gt;
如 html5的data是存已被cache等信息都存在jQuery.cache中，所以了解它将有助于我们排错。&lt;/p&gt;

&lt;h4 id=&quot;acceptdata-1672&quot;&gt;acceptData [1672]&lt;/h4&gt;

&lt;p&gt;内部使用accpetData检查元素是否允许使用data， 有三种元素不能使用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;embed
非flash object
applet
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置时，名称将会被转成camelCase，获取时如果直接获取不到, 则会尝试将名称转成camelCase再次获取&lt;/p&gt;

&lt;p&gt;所以目前&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;elm.data(&#39;a-b&#39;, &#39;value&#39;) -&amp;gt; 内容key为 aB
elm.data(&#39;aB&#39;), 没有问题
elm.data(&#39;a-b&#39;), 直接取不到, 会将key转换成aB再次读取
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Q： 上述读取时，为什么是先使用a-b进行读取，读不到再转成aB读，不能直接转成aB读取吗？&lt;br /&gt;
 A: 因为允许这种方式设置：elm.data({ ‘a-b’: ‘hello’ })&lt;br /&gt;
   而这次方式设置时，目前没有对key进行camel的转化（我估计是对代码没有重构彻底，所以这里做了兼容，后续行为应该会一致）&lt;br /&gt;
   PS: 看来jQuery的源码也和我们的代码一样，不是完美的&lt;/p&gt;

&lt;p&gt;所以：我们应该全部使用 camelCase来设置和读取，以做到向后兼容&lt;/p&gt;

&lt;h4 id=&quot;html5-data&quot;&gt;html5 data&lt;/h4&gt;

&lt;p&gt;读取时如果cache从取不到, 则会尝试从 html5 data属性中取&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var config = elm.data(&#39;modConfig&#39;); // 取自data-mod-config属性
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;读取data属性值，数据转换规则如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;1 &quot;true&quot; -&amp;gt; true
2 &quot;false&quot; -&amp;gt; false
3 &quot;null&quot; -&amp;gt; null
4 $.isNumberic(data) -&amp;gt; parseFloat(..
5 &quot;{...}&quot;或&quot;[...]&quot; -&amp;gt; parseJSON(...
	如果parseJSON失败，则为undefined
6 不转化，即返回源字符串
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;data-1&quot;&gt;关于data事件&lt;/h4&gt;

&lt;p&gt;这个特性jQuery文档中并未记录（可能是我没发现），但是这个代码从很早版本开始就有了, 1.4应该就有了，所以用用应该问题不大。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var elm = $(&#39;#mydiv1&#39;);

elm.bind(&#39;getData&#39;, function(value, name) {
  console.debug(&#39;getData&#39;, name, value);
  return &#39;new data&#39;;
});
elm.bind(&#39;setData&#39;, function(value, name) {
  console.debug(&#39;setData&#39;, name, value);
});
elm.bind(&#39;changeData&#39;, function(value, name) {
  console.debug(&#39;changeData&#39;, name, value);
});

// set
elm.data(&#39;myconfig&#39;, { url: &#39;http://www.google.com&#39; });

// get 
var value = elm.data(&#39;myconfig&#39;);
console.debug(value);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到通过绑定getData，我们可以响应data的事件，并且可以拦截取得的数据&lt;/p&gt;

&lt;p&gt;当然通过事件：setData 和 changeData, 我们可以在数据设置前/设置后 做一些工作。&lt;br /&gt;
感觉这里又有一个地方jQuery没做到位，就是setData应该也像getData一样，能够更改设置的值。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;静态和实例方法&lt;/h4&gt;

&lt;p&gt;jQuery有两个data方法，一个是静态的，一个是实例的， 即 jQuery.data 和 jQuery.fn.data，后者会调用前者进行实际的数据存取工作&lt;br /&gt;
我们应用代码中仅使用后者。&lt;/p&gt;

&lt;h3 id=&quot;queue&quot;&gt;queue&lt;/h3&gt;

&lt;p&gt;队列，一般用得比较少哦，有一个默认的fx的队列，动画使用的就是这个队列。 这个queue在jQuery中主要是为了动画而创建的。&lt;/p&gt;

&lt;p&gt;下面是使用queue的一个例子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;$(&#39;#button&#39;).click(function(e) {
  e.preventDefault();
  
  var elm = $(this);

  elm.delay(3000, &#39;my&#39;);
  elm.queue(&#39;my&#39;, function(next) {
    alert(&#39;反应慢&#39;);
    setTimeout(next, 5000);
  });
  elm.queue(&#39;my&#39;, function() {
    alert(&#39;又过了5秒&#39;);	
  });

  elm.dequeue(&#39;my&#39;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;promise-1&quot;&gt;promise&lt;/h3&gt;

&lt;p&gt;返回一个queue的promise接口, 默认是fx&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;$(&#39;#button2&#39;).click(function(e) {
  e.preventDefault();	
    
  $(&#39;#mydiv&#39;).animate({
    width: &#39;500px&#39;,
    height: &#39;200px&#39;	
  }).animate({
    &#39;margin-left&#39;: &#39;300px&#39;  
  }).animate({
    &#39;margin-top&#39;: &#39;300px&#39;  
  }).promise().done(function() {
    $(this).html(&#39;complete!&#39;);  
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;attr&quot;&gt;attr&lt;/h3&gt;

&lt;p&gt;逻辑参考jQuery.attr&lt;/p&gt;

&lt;h4 id=&quot;jqueryattrfn-jqueryattrfn&quot;&gt;1.  如果属性名称在jQuery.attrFn集合中， 采用相应的方法处理(参看jQuery.attrFn)&lt;/h4&gt;

&lt;p&gt;有: val, css, html,  text, data, width, height, offset&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;左边相当于右边
elm.attr(&#39;css&#39;, ...) -&amp;gt; elm.css(...);
elm.attr(&#39;val&#39;, ...) -&amp;gt; elm.val(...);

所以如果使用attr设置这些属性，如height, width, 也会得到可以预期的结果
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然我们自己使用时，不要依赖这个特性, 应该更明确地直接使用.css, .val等方法&lt;/p&gt;

&lt;h4 id=&quot;hook&quot;&gt;2.  接下来使用”hook模”式对一些特殊属性进行处理&lt;/h4&gt;

&lt;p&gt;jQuery.attrHooks集合中的属性采用hooks中的方法来处理(参看jQuery.attrHooks)&lt;br /&gt;
有 type, value, tabIndex等等&lt;/p&gt;

&lt;p&gt;根据浏览器支持的情况，attrHooks集合中的项会有不同，如IE中会对href,src,width,height,style等做特殊处理。 &lt;strong&gt;“这也提供了一种把特殊代码隔离的方法，我们可以用到实践中”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果是checked disabled readonly selected 等 boolean类型的attribute(参看rboolean)使用 boolHook&lt;br /&gt;
否则使用 nodeHook (即处理IE67不能使用getAttribute/setAttribute获取/设置一些属性, 如id/name)&lt;/p&gt;

&lt;p&gt;设置属性时， 首先使用hook方法，如果返回空(代码中是undefined)， 则使用 elm.setAttribute方法&lt;br /&gt;
获取属性时，首先使用hook方法，如果返回空(代码中是null), 则使用 elem.getAttribute方法&lt;/p&gt;

&lt;h3 id=&quot;prop&quot;&gt;prop&lt;/h3&gt;

&lt;p&gt;prop是直接读取/设置节点属性, 而attr使用 get/setAttribute来工作。 如我们使用 select.prop(‘selectedInde’) 或 checkbox.prop(‘checked’) 来获取属性。相当于 select[0].selectedIndex 或 checkbox[0].checked。&lt;/p&gt;

&lt;p&gt;处理流程如下：&lt;/p&gt;

&lt;p&gt;1. 使用jquery.propFix来 fix名称&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class -&amp;gt; className
for -&amp;gt; htmlFor
readonly -&amp;gt; readOnly
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2. 如果存在于 jQuery.propHooks中， 则使用相应方法处理&lt;br /&gt;
	目前好像只有tabIndex，我们不大走这个分支&lt;/p&gt;

&lt;p&gt;3. 第2步不行，则使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set：elm[name] = value
get: return elm[name]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;attrprop&quot;&gt;attr/prop&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;addClass()&lt;/code&gt; &lt;code&gt;removeClass()&lt;/code&gt; &lt;code&gt;toggleClass()&lt;/code&gt; &lt;code&gt;val()&lt;/code&gt; 等方法参数都可以是一个function。&lt;/p&gt;

&lt;p&gt;add/removeClass/toggleClass 参数可以是一个function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;elms.addClass(function(i) {
  return &#39;item&#39; + i; 
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;toggleClass不仅可以用来切换class状态，还可以&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var checked = checkbox.prop(&#39;checked&#39;); 
elm.toggleClass(&#39;selected&#39;, checked);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;val 可以正确地对 select进行取值/多选也可以(参看valHooks)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;sel.val(&#39;123&#39;), 会选中option.value相等的那个
sel.val(), 会返回选中的option的值, 如果是多选，会返回一个数组

sel.prop(&#39;selectedIndex&#39;) 获取选中的index 相当于sel[0].selectedIndex
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;attrhooks&quot;&gt;attrHooks&lt;/h3&gt;

&lt;p&gt;有父节点的button/input 的type属性是不允许被改的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;elm.attr(&#39;type&#39;, ...) 在jQuery中会抛出一个异常，来防止这种行为
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 23 Feb 2012 00:00:00 +0800</pubDate>
        <link>http://bencode.github.io/javascript/inside-jquery.html</link>
        <guid isPermaLink="true">http://bencode.github.io/javascript/inside-jquery.html</guid>
        
        
        <category>javascript</category>
        
      </item>
    
  </channel>
</rss>
