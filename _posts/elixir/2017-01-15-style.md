---
layout: post
title: Elixir Style Guide
categories: elixir
---

参考 [Elixir Guide Style](https://github.com/christopheradams/elixir_style_guide)


## 源代码格式

### 使用两个空格缩进，不使用Tab字符。


```elixir
def some_function do
  do_something
end
```

### 以下位置需要添加空格。

1. 操作符左右
2. 逗号分号和冒号后面
3. 模式匹配不加空格，如大括号和中括号的两端。

```elixir
sum = 1 + 2
{a, b} = {2, 3}
[first | rest] = [1, 2, 3]
Enum.map(["one", <<"two">>, "three"], fn num -> IO.puts num end)
```

### 一元操作符后不要加空格，range操作符左右也不要加空格。

```elixir
0 - 1 == -1
^pinned = some_func()
5 in 1..10
```

### def定义的函数之间使用空行分开，用于表达逻辑的独立性。


### 但是单行函数之间不要有空行。

```elixir
def some_function(nil), do: {:err, "No Value"}
def some_function([]), do: :ok
def some_function([first | rest]) do
  some_function(rest)
end
```

### 如果使用`do:`定义的函数，如果函数体太长，把`do:`另起一行，并且适当缩进。

```elixir
def some_function(args),
  do: Enum.map(args, fn(arg) -> arg <> " is on a very long line!" end)
```


### 如果使用do:定义函数，且有多个函数体，`do:`需要另起一行。

```elixir
# not preferred
def some_function([]), do: :empty
def some_function(_),
  do: :very_long_line_here

# preferred
def some_function([]),
  do: :empty
def some_function(_),
  do: :very_long_line_here
```


### 一行以上的函数体不要使用`do:`定义。


### 使用`|>`连接函数链式调用。

1. 链式调用优先使用 `pipe operator`
2. 多行`pipelines`不缩进
3. `=`右边的`pipelines`需要整体换行且缩进

```elixir
# not preferred
String.strip(String.downcase(some_string))

# preferred
some_string |> String.downcase |> String.strip

# Multiline pipelines are not further indented
some_string
|> String.downcase
|> String.strip

# Multiline pipelines on the right side of a pattern match
# should be indented on a new line
sanitized_string =
  some_string
  |> String.downcase
  |> String.strip
```


### 一个参数的函数调用就不要使用管道操作符了。

```elixir
# not preferred
some_string |> String.downcase

# preferred
String.downcase(some_string)
```


### 使用纯净的变量作为链式调用的开始。

```elixir
# THE WORST!
# This actually parses as String.strip("nope" |> String.downcase).
String.strip "nope" |> String.downcase

# not preferred
String.strip(some_string) |> String.downcase |> String.codepoints

# preferred
some_string |> String.strip |> String.downcase |> String.codepoints
```

## 语法

### 有参数的函数定义需要使用括号，无参数的函数则不需要。

```elixir
# not preferred
def some_function arg1, arg2 do
  # body omitted
end

def some_function() do
  # body omitted
end

# preferred
def some_function(arg1, arg2) do
  # body omitted
end

def some_function do
  # body omitted
end
```

### 多行`if/unless`不使用`do:`。

```elixir
# not preferred
if some_condition, do:
  # a line of code
  # another line of code
  # note no end in this block

# preferred
if some_condition do
  # some
  # lines
  # of code
end
```

### 单行`if/unless`使用`do:`。

```elixir
# preferred
if some_condition, do: # some_stuff
```

### 不要使用`unless`的`else`分支。

```elixir
# not preferred
unless success? do
  IO.puts 'failure'
else
  IO.puts 'success'
end

# preferred
if success? do
  IO.puts 'success'
else
  IO.puts 'failure'
end
```

### 总是用`true`作为`cond`的最后一个分支。

```elixir
cond do
  1 + 2 == 5 ->
    "Nope"
  1 + 3 == 5 ->
    "Uh, uh"
  true ->
    "OK"
end
```

### 函数调用时，函数名和括号之间不要有空格。

```elixir
# not preferred
f (3 + 2) + 1

# preferred
f(3 + 2) + 1
```

### 函数调用时使用括号，特别是在管道操作里。

```elixir
# not preferred
f 3

# preferred
f(3)

# not preferred and parses as rem(2, (3 |> g)), which is not what you want.
2 |> rem 3 |> g

# preferred
2 |> rem(3) |> g
```

### 宏调用时如果有do区块，不需要加括号。

```elixir
# not preferred
quote(do
  foo
end)

# preferred
quote do
  foo
end
```

### 函数调用最后一个参数是函数表达式时，可以有选择地省略括号。

```elixir
# preferred
Enum.reduce(1..10, 0, fn x, acc ->
  x + acc
end)

# also preferred
Enum.reduce 1..10, 0, fn x, acc ->
  x + acc
end
```

### 无参数的函数调用明确使用括号，可以避免和变量冲突。从Elixir 1.4 开始如果没有括号编译器会警告。

```elixir
defp do_stuff, do: ...

# not preferred
def my_func do
  do_stuff # is this a variable or a function call?
end

# preferred
def my_func do
  do_stuff() # this is clearly a function call
end
```

### 连续的with子句需要缩进和对齐，`do:`换行。

```elixir
with {:ok, foo} <- fetch(opts, :foo),
     {:ok, bar} <- fetch(opts, :bar) do
  {:ok, foo, bar}
else
  :error ->
    {:error, :bad_arg}
end
```
