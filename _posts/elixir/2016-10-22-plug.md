---
layout: post
title: Plug学习笔记
categories: phoenix plug elixir
---

类似于nodejs中的koa和中间件, ruby on rails中的rack，plug是phoenix中的web中间件规范。 
遵循plug规范的模块通过Web服务器配置器可以运行在Erlang虚拟机上。

以下就是一个最简单的Plug实现和运行示例。

```elixir
defmodule Server do
  import Plug.Conn


  def init(opts) do
    opts
  end


  def call(conn, _opts) do
    conn
    |> put_resp_content_type("text/plain")
    |> send_resp(200, "Hello world")
  end
end
```

```iex
{:ok, _} = Plug.Adapters.Cowboy.http Server, []
```


共有两种plug。

### 1. function plug

接入一个conn和一个options，返回一个conn的函数。


```elixir
def json_header_plug(conn, opts) do
  Plug.Conn.put_resp_content_type(conn, "application/json")
end
```

### 2. module plug

模块Plug需要定义两个函数 init 和 call。

```elixir
defmodule JSONHeaderPlug do
  import Plug.Conn

  def init(opts) do
    opts
  end


  def call(conn, _opts) do
    conn |> put_resp_content_type("application/json")
  end
end
```

init的返回值作为call的第二个参数，注意 init 可能会在编译期调用，因此不能返回运行时的对象，比如pid, port 等。


## Adapter


## Plug.Conn


这段代码有点意思

```elixir
defimpl Collectable, for: Plug.Conn do
  def into(conn) do
    {conn, fn
      conn, {:cont, x} ->
        {:ok, conn} = Plug.Conn.chunk(conn, x)
        conn
      conn, _ ->
        conn
    end}
  end
end
```
