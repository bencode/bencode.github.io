---
layout: post
title: Elixir Kernel 模块学习
categories: elixir
---


参考文档 https://hexdocs.pm/elixir/Kernel.htm


Kernel模块提供默认函数和宏，可以通过 `import/2` 来忽略或有选择性地加载指定函数和宏。


```elixir
iex(1)> if true, do: "ok"
"ok"
iex(2)> import Kernel, except: [if: 2]
Kernel
iex(3)> if true, do: "ok"
** (CompileError) iex:3: undefined function if/2
```

Kernel.SpecialForms中的元素不能被忽略。 模块中的有些方法(build-in internel functions BIFs)被内联到elixir编译器中.


### ==, ===, != 和 !==

需要注意 `!=` 和 `!==`的区别

```elixir
iex(1)> 1 == 1.0
true
iex(2)> 1 === 1.0
false

iex(3)> 1 == "1"
false

iex(4)> 1 != 1.0
false
iex(5)> 1 !== 1.0
true
```


### left ++ right

a ++ b的复杂度和length(a)成正比， 所以关键地方可以使用 [item | rest] 然后反转list达到目的。


### left -- right

移除元素，每个元素最多移除一次

```elixir
iex(6)> [1, 1, 2, 2, 3, 3] -- [1, 2, 2, 3]
[1, 3]
```

### left / right

结果总是float，如果需要取整或取模，使用 `div/2` 或 `rem/2`

```elixir
iex(15)> 8 / 2
4.0
iex(16)> 8 / 3
2.6666666666666665
iex(17)> div 8, 2
4
iex(18)> rem 8, 3
2
```

### left ~= right

正则式测试

```elixir
iex(25)> "abcd" =~ ~r/c(d)/
true
iex(26)> ~r/c(d)/ =~ "abcd" # 反过来会报错
** (FunctionClauseError) no function clause matching in Kernel.=~/2
    (elixir) lib/kernel.ex:1580: Kernel.=~(~r/c(d)/, "abcd")

iex(29)> "abcd" =~ "bc"     # 子串测试
true
```

### apply(fn, args), apply(module, fn, args)

这个类似于Javascript的Funtion#apply


### bit_size(), byte_size()

位大小和字节数

```elixir
iex(1)> str = "hello"
"hello"
iex(2)> bit_size str
40
iex(3)> byte_size str
5
iex(4)> str = "你好"
"你好"
iex(5)> bit_size str
48
iex(6)> byte_size str
6
```

### elem(tuple, index)


```elixir
iex(7)> o = {:ok, "hello world"}
{:ok, "hello world"}
iex(8)> elem(o, 1)
"hello world"
iex(9)> elem(o, 0)
:o
```

这可以用在guard test中比较有趣

```elixir
defmodule Test do
  def test(v) when elem(v, 1) > 2 do
    "ping"
  end

  def test(_) do
    "pong"
  end
end
```

```elixir
iex(1)> Test.test({:ok, 4})
"ping"
iex(2)> Test.test({:ok, 1})
"pong"
```



