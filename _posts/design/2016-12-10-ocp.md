---
layout: post
title: 软件设计原则之-OCP
categories: design
tags:
  - oo
---

怎么样的设计在面对需求变化时保持相对稳定呢？**开放封闭原则**（The Open-Closed Principle，简称OCP）为我们提供了指引。

这个原则说：**软件实体（类、模块、函数等等）应该是可以扩展的，但是不可修改的。**

咋一看，这说法似乎很矛盾，不修改怎么扩展呢？正确的理解方式应该是这样的：

好的设计，当需求变更时，我们应该只需要添加代码就可以搞定，而不需要修改原来写好的代码。

符合上述条件的模块（可能是类，函数、插件等等）就是遵循OCP原则的。   
假如某次需求变化要改一堆原来的代码，那么我们修改的目标，就是改完后要遵循OCP原则。  
下次有**相同类型**的需求变更时，我们将不再修改那一堆代码。这叫**受一次伤原则**。  

**遵循OCP原则的代码，对于扩展是开放的，而对于更改是封闭的。**仔细一想这原则本来就是我们追求的目标啊：我们希望自己写的软件在保持相对稳定的前提下能不断升级迭代。

下面再聊一下扩展性。

我们对于扩展性的理解比较朦胧，只是觉得它是个好东西，可是如何量化扩展性呢？  
一个软件能扩展，本质上是软件存在（被我们有意设计出来的）一个或多个自由度（想象成一根根滑竿），在自由度的方向上它能扩展。而和自由度不一致的方向上如果想滑的话就要改造。这个道理很容易理解。

那什么是自由度，即那一根根滑竿是什么？ 就是上一讲**单一职责原则（SRP）**中的职责，即**变化的原因**。  

现在我们重新定义一下扩展性（近来总看到重新定义一些东西，我也模仿一下）：

**软件中有多少职责遵循OCP原则**。

注意的是，这个**“变化的原因”** 不是那么容易找到的，这是设计的核心工作之一。
**它需要我们使用抽象的工具深入地思考才能得到。**

不过有个技巧就是，尝试用句式**“各种各样的XX”**来描述你的需求。比如：

这是一个验证组件。

它支持**各种各样的验证规则**，当前需要支持正则表达式验证，支持数字，身份证号码，邮箱地址，自定义规则等等。
它支持**各种各样的提示方式**，当前需要支持alert弹出框，支持div显示出错信息。
它支持**各种各样的事件触发方式**， 当前需要支持表单提交时验证，支持焦点移开时验证。

所以上面验证组件就会有三个自由度，即三个职责。**1. 验证规则  2. 提示方式  3. 事件触发方式。**  
我们需要独立地封装它们，让其能独立变化，遵循OCP原则。

再来一个示例。

这是一个产品展示组件。

它支持**各种各样的数据源。** 当前需要支持 搜索来源，坑位来源，指定id等。
它支持**各种各样的展现方式。**  当前需要支持 列表展示， 图文展示，表格展示。

所以这个产品组件有两个职责： **数据源和展现方式。**

