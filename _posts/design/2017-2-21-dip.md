---
layout: post
title: 软件设计原则之-DIP
categories: design, principle
---

依赖倒置原则(Dependency Inversion Principle -- DIP)

这个原则是这样描述的：

高层模块不应该依赖于低层模块，二者都应该依赖于抽象
抽象不应该依赖于细节，细节应该依赖于抽象

为了理解这个原则，就需要理解什么是高层模块，什么是低层模块，什么是抽象，什么又是细节。

我们分享了产品组件对不同数据源支持的设计。最简单的实现是这样子的：


![01](/assets/design/01.png)


ProductComponent此时就是所谓的高层模块，一般指的是“我们花大力气编写的代码”，对前端组件来说很可能就是渲染和交互的代码，而 SearchDataFetcher 和 SlotDataFetcher就是低层模块，这里通过ajax调用不同的数据源。 上面的实现一旦数据源变更（添加，修改等），我们就需要修改 ProductsComponent， 因为目前它不仅管理如何渲染，还管理如何获取数据。所以它对“数据源的变更不封闭”，即不满足OCP原则。

一般碰到这种情况，我们需要引入一个中间层来解决，重构后的设计象这样：


![02](/assets/design/02.png)


我们引入了 DataFetcher这个接口， 由于javascript动态语言，所以这个接口实际上只存在于约定之中。而在Java，C#，C++等语言中会有相应的实体存在。这样修改后，数据源的添加或删除将不需要修改 ProductsComponent的这个模块， 这个模块的逻辑（渲染和交互）就会稳定下来。

原来的依赖关系是，ProductsComponent依赖于具体的Fetcher，现在是 具体的Fetcher依赖于 ProductsComponent，这也是为什么这个原则名字叫依赖倒置原则， 英文名叫：Dependency Inversion Principle，简称DIP，也叫依赖反转原则。

这里虚线框将 DataFetcher(协议，或称接口) 和 ProductsComponent (客户)框在一起是表示， 协议属于客户，而不属于实现者。 类比 操作系统对显卡厂商的支持， 标准是由操作系统厂商（比如微软）或者某个标准组织制定的，而生产商只是实现它，否则它的硬件将没有用处。

上面的接口（协议）是一种抽象，用来描述一类操作。领取中心为了让优惠券的渲染和交互保持稳定，抽象出标准的Coupon数据模型。


![02](/assets/design/03.png)


我们引入的中间层是 Coupon这个数据模型， CouponRender将不再直接依赖于具体的Coupon，它可以单纯地负责自己渲染和交互逻辑。 而把取数，变换等经常变的代码隔离在 CouponContainer中。

将软件抽象成不同的层，每个层有不同的稳定性，这样需求变更或迭代过程中，我们都很清晰地只修改一小部分模块，而不需要动大多数内容，这就是好的设计。如果是牵一发而动全身的设计，就是不好的设计，需要重构。

重构的方式是引入一个间接层，即引入一个抽象将依赖反转，有可能是添加一个接口（或协议），也有可能是标准化一个数据模型。
