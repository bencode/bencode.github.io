---
layout: post
title: 《SICP》笔记 1.1 程序设计的基本元素
categories: sicp
---

章节前面的引言就很有意思：

```
  心智的活动，除了尽力产生各种简单的认识之外，主要表面在如下三个方面：
  1. 将若干简单认识组合为一个复合认识，由此产生出各种复杂的认识。
  2. 将两个认识放在一起对照，不管它们如何简单或复杂，在这样做时并不将它们合而为一。由此得到有关它们的相互关系的认识。
  3. 将有关认识与那些在实际中和它们同在的所有其他认识隔离开，这就是抽象，所有具有普遍性的认识都是这样得到的。
  -- John Locke, 有关人类理解的随笔，1690
```

这是一种元认知能力，或者说的是一种方法：

- 我们可以通过组合简单的认知形成新的认知；  
- 通过对比不同的认知，形成新的认知；  
- 也可以从一堆认知中挖掘共性，抽象出新的认知。  

这本书的内容可以认为是在编程领域实践上面的方法论。


## 用Lisp编程

语言那么多，为何是`Lisp`？

本书探讨的是编程的本质问题，而目前多数语言会掩盖这些本质，又或仅仅包含所涉及编程语言能力的一个子集。   
不管你相信与否，编程语言的能力是有差别的，而`Lisp`的与其说是一门编程语言不如说它是数学，这一点在《黑客与画家》这本书中有较详细的描述。   

我们知道使用某种语言编写好的代码需要借助其解释器或编译器才能运行，如果在语言规则之外添加额外功能，就需要修改解释器或编译器才能实现。 而`Lisp`并不区分代码和数据，即可以把代码当作数据来处理，自己可以是自己的解释器，即`Lisp`具有进化能力，可以随着编程技术的发展而发展，比如让其支持**面向对象**或**函数式编程**的能力。

第一次看`Lisp`代码会被其层层嵌套的**括号**和极其学术的**前缀表达式**所吓到，但这仅仅是表象。  
事实是： 任何程序都可以用**树**来描述， 而`Lisp`是使用顺序结构描达这种树结构的最简方法。    
一棵树可以包含多个子元素， 而每个子元素可能又是一根树。 `Lisp`使用括号描述一棵树，不同的子元素使用空格分开，仅此而已。

```ss
(define (sum x y)
  (+ x y)
)
```

以上代码表达以下树结构

```ss
   define
    /   \
  sum    +
  / \   / \
 x   y  x  y
```

以上树结构定义了一个叫`sum`的函数，用于将两个数相加。

刚刚认识了`Lisp`的表达式，这种表达式有个很酷的专用名词叫**S表达式**， 相对于我们常见的表达式，我觉得前缀表达式的可读性会差点，这可能有一部分习惯的原因。  

比如练习1.2，用Javascript表达就是

```js
(5 + 4 + (2 - (3 - (6 + 4 / 5)))) / (3 * (6 - 2) * (2 - 7))
```

使用`Lisp`表达就是

```ss
(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5))))) (* 3 (- 6 2) (- 2 7)))
```

如果格式化后就会清晰很多

```ss
(/ (+ 5
      4
      (- 2
         (- 3
            (+ 6
               (/ 4 5)))))
   (* 3
      (- 6 2)
      (- 2 7)))
```

语言会影响思维方式，所以一门好的编程语言应该为更好地解决问题提供机制。 强有力的语言都为此提供三种机制：

- 基本表达式
- 组合的方式
- 抽象的方法


## 练习1.5

Ben Bitdiddle发明了一种检测方法，能够确定解释器究竟采用哪种序求值，是采用应用序，还是采用正则序。他定义了下面两个过程：

```ss
(define (p) (p))

(define (test x y)
  (if (= x 0)
    0
    y))

(test 0 (p))
```

过程应用的代换模型主要用于帮助我们领会调用时的情况，共有两种代换模型： 应用序和正则序。  

过程应用就是平常所说的函数调用，我们接触到的函数调用，都是先求值参数，再使用参数的结果调用函数， 这被称为应用序。  
还有一种是不求值参数，使用参数的表达式替换函数体中的形参，这类似于一些语言（如Lisp或Elixir)中的宏。

所以看练习题：
如果是应用序的话，需要求值p， 而p是一个不断调用自身的递归函数，因此就出不来了。  
如果是正则序，则不会先求值p, 最终由于条件不满足也不会调用p。  



